<!DOCTYPE html>
<html>
  <head>
    <title>The did:orb Method v0.1</title>
    <meta charset='utf-8'>
    <script src='https://www.w3.org/Tools/respec/respec-w3c' async class='remove'></script>
    <script class='remove'>
      var respecConfig = {
        specStatus: "unofficial",
        subtitle: "A DID Method for a fediverse of interconnected nodes and witnesses",
        editors: [{
          name: "Troy Ronda", url: "https://www.linkedin.com/in/troyronda/",
          company: "SecureKey", companyURL: "https://securekey.com/"
        }],
        github: "https://github.com/trustbloc/did-method-orb",
        localBiblio: {
          SIDETREE: {
            title: "Sidetree v1.0.0",
            href: "https://identity.foundation/sidetree/spec/v1.0.0/",
            authors: ["D. Buchner, O. Steele, T. Ronda"],
            publisher: "Decentralized Identity Foundation",
            status: "DIF Ratified Specification"
          },
          DIDRESOLUTION: {
            title: "Decentralized Identifier Resolution (DID Resolution)",
            href: "https://w3c-ccg.github.io/did-resolution/",
            publisher: "W3C CCG",
            status: "Draft Community Group Report"
          },
          LDPROOF: {
            title: "Linked Data Proofs 1.0",
            href: "https://w3c-ccg.github.io/ld-proofs/",
            publisher: "W3C CCG",
            status: "Draft Community Group Report"
          },
          CID: {
            title: "CID (Content IDentifier) Specification",
            href: "https://github.com/multiformats/cid",
            publisher: "Multiformats"
          }
        }
      };
    </script>
  </head>
  <body>
    <section id='abstract'>
      <p>
        Orb is a decentralized identifier (DID) method based on a federated and replicated
        <a href="https://www.w3.org/TR/did-core/#dfn-verifiable-data-registry">Verifiable Data Registry</a> (VDR).
        The decentralized network consists of Orb servers that write, monitor, witness, and propagate batches of DID operations.
        The batches form a graph that is propagated and replicated between the servers as content-addressable objects.
        These content-addressable objects can be located via both domain and distributed hash table (DHT) mechanisms.
        Each Orb witness server observes a subset of batches in the graph and includes them in their ledgers (as append-only Merkle Tree logs).
        The servers coordinate by propagating batches of DID operations and by monitoring the applicable witness servers' ledgers.
        The Orb servers form a decentralized network without reliance on a common blockchain for coordination.
      </p>

      <p>
        This document specifies the Orb DID Method along with a data model and rules for representing a graph of batches, 
        the Orb server API, a registry of protocol versions and parameters,
        an [[[ACTIVITYSTREAMS-CORE]]] vocabulary and an [[[ACTIVITYPUB]]] profile for propagating batches,
        a [[[RFC7033]]] profile for discovering endpoints, a [[[SIDETREE]]] protocol profile for encoding DID operations,
        and a [[[RFC6962]]] profile for witness ledgers.
      </p>
    </section>
    <section id='sotd'>
      <p>
      </p>
    </section>
    
    <section class="informative">
        <h2>Introduction</h2>
        <p>
          The Orb DID method enables users or entities to create <a href="https://identity.foundation/sidetree/spec/#did-uri-composition">self certifying</a>
          decentralized identifiers (DIDs) that are propagated across a decentralized network without reliance on a common blockchain for coordination.
          Decentralized identifiers [[DID-CORE]] are a fundamental building block to enable persons and entities to prove that they control an identifier
          that is attached to digital objects such as Verifiable Credentials [[VC-DATA-MODEL]].
        </p>

        <p>
          Systems that rely on <i>self certifying</i> DIDs need a
          mechanism to propagate the ordered updates to DID documents from the server writing operations to their DID resolver.
          As an example, operations can be distributed via a content-addressable network (such as <a href="https://ipfs.io">IPFS</a>)
          and announced on a public blockchain (such as <a href="https://bitcoin.org">Bitcoin</a>) or a permissioned blockchain
          (such as <a href="https://www.hyperledger.org/use/fabric">Hyperledger Fabric</a>). This DID method, instead, makes use of
          decentralized federation protocols to propagate announcements and replicate content in a <a href="https://en.wikipedia.org/wiki/Gossip_protocol">gossip manner</a>.
          By using a decentralized federation mechanism, we have no need to choose a common blockchain nor rely on a consortium's
          <a href="https://en.wikipedia.org/wiki/Distributed_ledger">distributed ledger</a> (DLT) for coordination.
          Orb has the ability to enable use cases where a public blockchain is not acceptable to stakeholders and also avoids lock-in to a single DLT. 
        </p>

        <p>
          As operations on DIDs can be originated by different writers in a decentralized network, it is also beneficial to enable a mechanism for determining
          the latest operations for a particular suffix. For example, when all DID operations are announced by the same blockchain, the other systems can
          monitor that blockchain for the latest operations. These blockchains can also provide relative timing in cases of 
          <a href="https://identity.foundation/sidetree/spec/#late-publishing">late publishing</a>. This DID method, instead, makes use of independent witness ledgers
          that the DID controller can associate with their DID. These witness ledgers can be monitored as additional propagation sources and proofs from these ledgers can
          also provide relative timing confidence in cases of late publishing. Rather than being a global chain of all operation announcements, these ledgers contain
          a subset of the announcements that propagate through the decentralized federation protocols.
        </p>
          
        <p>
          The property of self certifying DIDs is obtained due to Orb being an extension of the [[[SIDETREE]]] protocol.
          By using the Sidetree protocol, the DID controller forms their own verifiable chain of patches from inception to the current state of the DID document.
          These verifiable chains are included into larger batches by one of the independent Orb servers and encoded as content-addressable objects. We also
          inherit the scalability properties of the Sidetree protocol batch strategy.
        </p>

        <p>
          Our motivation for the Orb DID method is to enable many independent organizations to create <a href="https://www.w3.org/TR/did-core/#dfn-verifiable-data-registry">
          Verifiable Data Registries</a> (VDRs) that can become connected over time.
          In designing Orb, we have the goal to enable these VDRs to interconnect into a decentralized network without the need to choose a common public
          blockchain or to rely on special-purpose consortiums to form (and remain in operation). By using decentralized federation protocols and witness ledgers, 
          we enable <i>self-certifying</i> DIDs even in use cases where leveraging a public blockchain or a consortium DLT is not acceptable to stakeholders.
          Orb enables a federated, replicated and scalable VDR based on a decentralized network for propagating, witnessing and replicating changes to DID documents.
        </p>

    </section>

    <section class="normative">
      <h2>Concepts</h2>

      <p>
        Orb uses a propagation model where servers announce transactions to other servers that are following them.
        In general, <i>Orb Servers</i> have the capability to propagate transactions and replicate Orb 
        <a href="https://www.w3.org/TR/did-core/#dfn-verifiable-data-registry"> Verifiable Data Registries</a> (VDRs).
        Beyond propagation and replication, there are three primary <i>Orb Server</i> roles in the transaction flow:
      </p>
      
      <ul>
        <li>Writer: Accepts operations from DID controllers to update their DIDs, batches operations, and creates an Orb transaction from each batch.</li>
        <li>Witness: Provides decentralized timestamping and partial ledger histories for Orb transactions. Accepts <i>preannouncements</i> of Orb transactions from Writers.</li>
        <li>Resolver: Responds to Requesting Party (RP) requests for DID resolution.</li>
      </ul>

      <figure>
        <img src="diagrams/flow-model.svg" style="max-width: 50%;"/>
        <figcaption>
          Orb transaction propagation model
        </figcaption>
      </figure>

      <p>
        Orb servers apply both the DID controller's intention and also observed timings to resolve scenarios where a DID update is applied
        at the same sequence position in the DID's operation chain.
        As the DID controller is fully responsible for the changes to their DIDs, they can create a new branch in their operation chain even after time has passed.
        Orb Servers use rules to determine the <i>first published branch</i> and use observations to assist in that decision as follows:
      </p>

      <ul>
        <li>Operation timestamps are used to limit inclusion into a new transaction: allow the DID controller to signal that an operation is stale.</li>
        <li>Transaction and propagation timestamps from Orb servers indicate when they first observed a transaction.</li>
        <li>Independent decisions on the trustworthiness of an Orb server based on the ability to monitor their consistency over time (and other independent factors for each system).</li>
        <li>Ability to monitor the consistency of a Witness server's timestamps and relative ordering of transactions based on their append-only ledger.</li>
        <li>The ability for a DID controller to associate to a Witness ledger. The DID controller's behavior, as observed by that Witness, has extra weight as a tie-breaker.</li>
      </ul>

      <p>
        The following diagram provides an example of applying the stale rule to <i>DID B</i> and the usage of a Witness associated to <i>DID A</i> as a tie-breaker to resolve a branch.
      </p>

      <figure>
        <img src="diagrams/branch-model.svg" style="max-width: 50%;"/>
        <figcaption>
          Orb branch rules example
        </figcaption>
      </figure>

      <p>
        Transactions are structured as a content-addressable graph.
        An Orb server accepts operations from DID controllers and periodically creates a Sidetree batch consisting of operations from multiple DIDs.
        From the batch, a <i>pretransaction</i> is created that includes CIDs of the most recent transaction for each DID from the <i>Writer server's point of view</i>.
        The Writer <i>preannounces</i> the transaction to a set of Witnesses.
        Each Witness promises to include the transaction in their ledger by returning a timestamped and signed pretransaction.
        The Orb server then propagates the combination of the pretransaction with the timestamped witness signatures as a new transaction.
      </p>

      <p>
        Orb enables the VDR to be replicated between independent systems to increase the overall resilience of the ecosystem.
        The transaction model includes Witness signatures as a common Orb format regardless of the Witness ledger implementation.
        To achieve our system monitoring properties, we assume a Witness holds a <i>monitorable</i> ledger that stores timestamped transactions with an append-only model.
        Witness ledgers can be replicated and monitored for consistent behavior.
        In particular, monitoring systems validate:
      </p>

      <ul>
        <li>The ledger contains the transactions that were promised to be included.</li>
        <li>Consistency between Merkle Tree heads (append-only).</li>
        <li>Consistency of timestamping - time moves forward as new Merkle Tree heads are created.</li>
      </ul>

      <figure>
        <img src="diagrams/data-model.svg" style="max-width: 50%;"/>
        <figcaption>
          Orb transaction data model
        </figcaption>
      </figure>

      We enable both a Web API for content-addressable storage (including endpoint discovery) and also <a href="https://en.wikipedia.org/wiki/Distributed_ledger">Distributed Hash Tables</a> (DHTs) such as <a href="https://ipfs.io">IPFS</a>.
      This specification also includes a Witness ledger profile based on certificate transparency [[RFC6962]].

      <section class="normative">
        <h3>Self Certifying Decentralized Identifiers</h3>

        <p>
          Orb DIDs are <i>self certifying</i>.
          The data structure that encodes the ordered updates to a DID document form their own verifiable chain from inception to the current state of the DID document.
          We inherit this property due to our usage of the [[[SIDETREE]]] protocol for encoding the DID document updates.
        </p>
      </section>

      <section class="normative">
        <h3>Propagation via Decentralized Federation</h3>

        <p>
          Orb makes use of decentralized federation protocols to propagate announcements and replicate content in a
          <a href="https://en.wikipedia.org/wiki/Gossip_protocol">gossip manner</a>. We use [[[ACTIVITYSTREAMS-CORE]]] and [[[ACTIVITYPUB]]].
          In later sections, we describe the vocabulary and profile for using these protocols in Orb.
        </p>

        <p>
          Orb does not rely on public blockchains nor DLTs to coordinate - there is no need for network consensus. Instead, we rely on
          self certifying DIDs being propagated and the ability to replicate VDRs in a gossip manner. 
        </p>
      </section>

      <section class="normative">
        <h3>DID Updates Are Batched</h3>

        <p>
          Modifications to DID documents that are sent to an Orb servers are aggregated into batches prior to being announced on the decentralized network.
          By supporting batching, we enhance the scalability properties due to a reduction in messages and objects being stored.
          We inherit this property due to our usage of the [[[SIDETREE]]] protocol for encoding the DID document updates.
        </p>
      </section>

      <section class="normative">
        <h3>DID Updates Batches Form a Graph</h3>

        <p>
          When writing a batch of DID document updates, an Orb server also includes immutable references to the prior batches.
          These references form a graph (in the form of a Merkle Tree) such that the ancestor operations can be processed prior to a newly observed batch.
          This property is needed in the Orb data structures since we do not have a common blockchain to provide this history.
        </p>

        <p>
          When a DID controller supplies their DID, they also include a reference to a batch in their DID string. This reference allows an Orb server to discover
          the graph where a DID was created (or more generally where a <a href="https://identity.foundation/sidetree/spec/#core-index-file">core Sidetree</a> update occurred).
          This reference also enables the DID controller to specify a minimum version of the DID document that must be discovered in order to resolve.
        </p>
      </section>

      <section class="normative">
        <h3>CAS-based Verifiable Data Registry</h3>

        <p>
          The Orb VDR leverages <a href="https://en.wikipedia.org/wiki/Content-addressable_storage">Content-Addressable Storage</a> (CAS) to hold the DID document batch files.
          The processed batch files result in hosting resolvable DID documents.
          By supporting a CAS, we enhance the ability to replicate immutable content across the decentralized network.
          We inherit this property due to our usage of the [[[SIDETREE]]] protocol for encoding the DID document updates and batches.
        </p>

        <p>
          We also leverage the CAS to hold the graph of batches. The immutable references to prior batches are in the form of <a href="https://docs.ipfs.io/concepts/content-addressing/">content identifiers</a> (CIDs).
        </p>
      </section>

      <section class="normative">
        <h3>Witnesses Resolve Late Publishing</h3>

        <p>
          The Orb method relies on decentralized federation, gossip and CAS replication mechanisms to propagate
          the VDR among servers. The self certifying nature of Orb DIDs enables confidence in the DID validity without the need
          for network consensus.
          As the DID controller is fully responsible for the changes to their DIDs, they can create a new branch in their operation chain even after time has passed.
          This situation is called <a href="https://identity.foundation/sidetree/spec/#late-publishing">late publishing</a>.
          The resolver systems require a mechanism to decide which branch should be used to represent the current DID state.
          It is also beneficial to create rules that enable a consistent viewpoint of the active branch among interconnected Orb servers.         
          Resolver systems use rules to determine the <i>first published branch</i> and use observations from Witness systems to assist in that decision.
        </p>

        <p>
          In the absence of Witnesses, we start with a simple rule: the first branch of a DID observed by an Orb server is the first published branch
          for that DID <i>from that server's point of view</i>. As Orb servers become increasingly interconnected, batches are gossiped between
          the Orb servers. Each server that forwards a batch includes a signed timestamp of when they observed the batch. The Orb Server MAY
          designate some of the other Orb servers as <i>trusted</i>. These trusted servers are then used to determine relative timing between batches.
          In the case that a majority viewpoint of itself and the other <i>trusted</i> Orb servers exists, that majority viewpoint will be used to
          determine the relative timing of the batches. From the relative timing of the batches, we also resolve the relative timing of the branch in the DID.
          An Orb server does not wait for consensus - its viewpoint may eventually converge to a majority view, over time, in these situations.
        </p>
       
        <p>
          Rules exist to resolve the active branch so that Orb servers can consistently resolve the DID controller's intended and current DID document. 
          To mitigate against initial divergences, we also introduce the Witness role to observe a transaction prior to propagation.
          The Orb transaction writer <i>preannounces</i> the existence of an Orb transaction by submitting it to a Witness.
          A Witness creates a proof that they observed an Orb transaction at a certain time.
          Witnesses have the capability to provide timestamping and also host a Witness Ledger to provide relative ordering between merged sets of Orb Transactions.
        </p>

        <p>
          Although each Orb Server decides who to designate as trusted, it is also important that an Orb Server's behavior can be monitored.
          We use a Witness ledger as the mechanism for monitoring behavior - if inconsistencies are detected, other systems can adjust their viewpoint
          for trustworthiness.
          A Witness ledger is responsible for recording individual Orb transactions, providing signed transaction timestamps
          that can be embedded within a propagated Orb transaction, providing ledger consistency proofs, and providing an API that exposes their ledger.
          A Witness ledger is not responsible for maintaining the Orb transaction graph structure nor is it responsible for maintaining a complete history of Orb transactions.
          An Orb server is monitorable by exposing a Witness ledger API.
        </p>

        <p>
          We structure witnesses ledgers in a similar manner to certificate transparency [[RFC6962]], as append-only Merkle Trees with proof capabilities.
          A Witness ledger promises to include a submitted Orb transaction within a time period known as the Maximum Merge Delay (MMD).
          Once the ledger merges a set of Orb transactions into the Merkle Tree, a Signed Tree Head (STH) is produced.
          The STH (and associated Merkle Proofs) is used to validate consistency between older and newer ledger revisions.
        </p>

        <p>
          When an Orb server creates a transaction, the server requests other Orb servers (as Witnesses) to include the transaction into their Witness ledger.
          The Orb server <i>preannounces</i> a transaction to Witnesses after preparing and writing the Sidetree CAS objects.
          The transaction announcement is then sent to Witnesses for validation and inclusion by the Witnesses.
          Each witnesses validates the Orb transaction structure and that it was issued within an acceptable delta of their current time.
          Upon successful validation, each witness returns a signed transaction timestamp and a promise to include the Orb transaction into their Ledger.
          The Orb transaction (combined with the signed transaction timestamps) is then written into the CAS and propagated.
          When an Orb Server receives a propagated transaction, they invalidate (as stale) each Sidetree operation that has a timestamp that is not within an acceptable delta of the Orb transaction's timestamp.
          When these proofs originate from <i>trusted</i> servers, their timing information is immediately applied after receiving an Orb transaction propagation.
          An Orb server that receives witnessed transactions from trusted servers likely holds the majority timing view immediately in these situations.
        </p>
      </section>

      <section class="normative">
        <h3>Witnesses Propagate for a DID</h3>
        <p>
          As Orb relies on gossip replication, it is possible for a resolver system to miss transactions originating from other servers that they do not follow.
          To mitigate this issue for a particular DID, we allow the DID controller to specify a witness policy.
          This policy contains a set of witnesses that MUST be used when an Orb transaction includes changes to the associated DID.
          The Writer server ensures that, according to the DID's policy, a sufficient number of these server(s) are also acceptable as Witnesses to the Writer server.
          If the DID's policy is unacceptable to the Writer server, the operation MUST be rejected and not included into the Orb transaction. The
          DID policy ensures that the Resolver Servers can determine if they have the latest propagations and that the DID controller can use any
          Writer server that has mutually acceptable policies.
        </p>

        <p>
          As a DID can be associated to a particular Witness, that Witness provides observations of the DID controller's behavior.
          In addition to propagating for a DID, the associated Witness is also given extra weight as a tie-breaker for resolving the late publishing scenario described in the previous section.
        </p>

        <p>
          The ability to set (or change) the policy is an operation that is included into a propagated <a href="https://identity.foundation/sidetree/spec/#core-index-file">Sidetree core index</a>.
        </p>

      </section>

      <section class="normative">
        <h3>Web Discovery APIs are Supported</h3>

        <p>
          The Orb DID method enables CAS discovery and usage via Web APIs. The WebFinger protocol [[RFC7033]] allows systems to query for both
          [[ACTIVITYPUB]] endpoints and also for CAS endpoints for a given resource. By enabling a fully Web-enabled model, we do not introduce
          a requirement on <a href="https://en.wikipedia.org/wiki/Distributed_hash_table">Distributed Hash Table</a> (DHT) usage into the method.
        </p>
      </section>

      <section class="normative">
        <h3>Distributed Hash Tables are Supported</h3>

        <p>
          Although Orb DIDs can be created that do not have a dependency on DHTs, we also enable optional support for registering CAS resources on a DHT.
          Orb servers MAY choose to expose their CAS-based VDRs on a <a href="https://en.wikipedia.org/wiki/Distributed_hash_table">Distributed Hash Table</a> (DHT) network such as IPFS. 
          When using a DHT, we gain the advantage of not needing to specify any Web domain to be queried for discovery.
        </p>
      </section>

      <section class="normative">
        <h3>Graphs Enable Propagation Discovery</h3>

        <p>
          The Orb transaction graph that is stored into the content-addressable storage (CAS) also enables discovery of propagation properties.
          Each node in the transaction graph includes known CAS discovery information and witness endpoints.
          The CAS discovery information enable Orb servers to include additional endpoints when responding to WebFinger [[RFC7033]] queries.
          The witness endpoints enable Orb servers to follow additional systems for propagation.
        </p>

      </section>

    </section>

    <section class="normative">
        <h2 id="format">The did:orb Format</h2>

        <p>
            The format for the <tt>did:orb</tt> method conforms to the [[[DID-CORE]]] specification.
            The DID scheme consists of the did:orb prefix, the mechanism for discovering content-addressable objects,
            a content identifier (CID) for the minimum node in the DID operation batch graph, and the unique suffix of the DID.
        </p>
        
        <p>  
            The method uses the following ABNF [[RFC5234]] format:
        </p>

        <pre>
          did-orb-format        = "did:orb:" (orb-canonical-did / orb-scheme-did / unpublished-did)
          orb-canonical-did     = min-graph-cid ":" did-suffix
          orb-scheme-did        = (dht-scheme / webcas-scheme) ":" orb-canonical-did
          unpublished-did       = "interim:" (web-interim-scheme / local-interim-scheme)
          dht-scheme            = ( "ipfs" )
          webcas-scheme         = "webcas:" reg-name
          web-interim-scheme    = reg-name ":" did-suffix
          local-interim-scheme  = "local" ":" did-suffix [":" long-form-suffix-data]
          reg-name              = 1*idchar                ; more constrained than [RFC3986]
          min-graph-cid         = 10*idchar               ; a short 3rd segment is reserved for schemes.
          did-suffix            = 1*idchar
          long-form-suffix-data = 1*idchar                ; only applicable in the local-scheme
        </pre>

        <p>
          See [[?RFC3986]] for the original definition of reg-name and [[DID-CORE]] for the definition of idchar.
          [[SIDETREE]] provides additional explanation for the <i>did-suffix</i> and <i>long-form-suffix-data</i> elements.
        </p>

        <pre class="example" title="A canonical Orb DID">
          did:orb:bafkreiatkubvbkdidscmqynkyls3iqawdqvthi7e6mbky2amuw3inxsi3y:EiDyOQbbZAa3aiRzeCkV7LOx3SERjjH93EXoIM3UoN4oWg
        </pre>

        <pre class="example" title="An Orb DID that uses the WebCAS scheme for content discovery">
          did:orb:webcas:example.com:bafkreiatkubvbkdidscmqynkyls3iqawdqvthi7e6mbky2amuw3inxsi3y:EiDyOQbbZAa3aiRzeCkV7LOx3SERjjH93EXoIM3UoN4oWg
        </pre>

        <pre class="example" title="An Orb DID that uses the IPFS scheme for content discovery">
          did:orb:ipfs:bafkreiatkubvbkdidscmqynkyls3iqawdqvthi7e6mbky2amuw3inxsi3y:EiDyOQbbZAa3aiRzeCkV7LOx3SERjjH93EXoIM3UoN4oWg
        </pre>

        <p class="issue" title="default DHT">
          TODO: discussion about the possibility of a DHT profile for Orb.
        </p>

        <p class="issue" title="maximum scheme length">
          TODO: use an appropriate length to differentiate CID from scheme.
        </p>
      </section>

    <section class="normative">
        <h2>Client-to-Server Operations</h2>

        <p>
          The Orb DID method extends the operations specified in the [[SIDETREE]] specification.
        </p>

        <section class="normative">
            <h3>Create</h3>

            <p>
              An Orb DID is created by submitting a <i>create</i> to the operations endpoint of an Orb Server,
              as specified in <a href="https://identity.foundation/sidetree/spec/#create">Sidetree</a>.
            </p>

            <p>
              Detailed steps are specified in the <a href="https://identity.foundation/sidetree/api/#create">Sidetree API</a>.
            </p>
        </section>

        <section class="normative">
            <h3>Read</h3>

            <p>
              An Orb Server exposes a DID resolution API as defined in [[DID-CORE]] using the HTTP(S) Binding specified by [[DIDRESOLUTION]].
            </p>

            <p>
              Detailed steps and additional method metadata properties are specified in the <a href="https://identity.foundation/sidetree/api/#sidetree-resolution">Sidetree API</a>.
            </p>
        </section>

        <section class="normative">
            <h3>Update</h3>

            <p>
              An Orb DID is created by submitting an <i>update</i> to the operations endpoint of an Orb Server,
              as specified in <a href="https://identity.foundation/sidetree/spec/#update">Sidetree</a>.
            </p>

            <p>
              Detailed steps are specified in the <a href="https://identity.foundation/sidetree/api/#update">Sidetree API</a>.
            </p>
        </section>

        <section class="normative">
          <h3>Recover</h3>

          <p>
            An Orb DID is recovered by submitting a <i>recover</i> to the operations endpoint of an Orb Server,
            as specified in <a href="https://identity.foundation/sidetree/spec/#recover">Sidetree</a>.
          </p>

          <p>
            Detailed steps are specified in the <a href="https://identity.foundation/sidetree/api/#recover">Sidetree API</a>.
          </p>
        </section>

        <section class="normative">
            <h3>Deactivate</h3>

            <p>
              An Orb DID is deactivated by submitting a <i>deactivate</i> to the operations endpoint of an Orb Server,
              as specified in <a href="https://identity.foundation/sidetree/spec/#deactivate">Sidetree</a>.
            </p>

            <p>
              Detailed steps are specified in the <a href="https://identity.foundation/sidetree/api/#deactivate">Sidetree API</a>.
            </p>
        </section>

        <section class="normative">
          <h3>Propagation Delay and Canonical IDs</h3>

          Orb DIDs support Sidetree <a href="https://identity.foundation/sidetree/spec/#did-uri-composition">DID URI Composition</a>
          for the <i>did-suffix</i> and <i>long-form-suffix-data</i> elements.
          
          An Orb resolver with previous knowledge of a particular suffix (or with the inclusion of <i>long-form-suffix-data</i>) is able
          to return a resolution result without additional prefix information.
          This situation typically occurs when there is a need to immediately use a freshly created DID suffix that hasn't yet been propagated.

          <pre class="example highlight" title="Locally known DID">
            did:orb:interim:local:EiA329wd6Aj36YRmp7NGkeB5ADnVt8ARdMZMPzfXsjwTJA
          </pre>
          
          <pre class="example highlight" title="Long-form DID">
            did:orb:interim:local:EiA329wd6Aj36YRmp7NGkeB5ADnVt8ARdMZMPzfXsjwTJA:ey...
          </pre>

          <pre class="example highlight" title="Not yet propagated DID only known to example.com">
            did:orb:interim:example.com:EiA329wd6Aj36YRmp7NGkeB5ADnVt8ARdMZMPzfXsjwTJA
          </pre>

          When an Orb Server has propagation information for a resolved DID, the server includes the <i>min-graph-cid</i> segment within the <i>canonicalId</i>
          property of the returned DID document metadata.
          The <i>min-graph-cid</i> is set to the CID of the latest known AnchorCredential that contains a <i>Create</i> or <i>Recover</i> operation for the DID.

          After a DID controller sends a <i>Create</i> or <i>Recover</i> operation to an Orb Server, the resolution result may have no (or an outdated) <i>min-graph-cid</i> segment.
          The DID controller may need to retry resolution until the operation has been propagated and the CID becomes available.
          Once the CID is available, resolution responses contain the updated <i>canonicalId</i> property.
        </section>

        <section class="normative">
          <h3>CAS Discovery and Equivalent IDs</h3>

          Orb DIDs support hints to enable a resolver to discover a CAS that is hosting the min-graph-cid in the DID string.
          A hint can be added to an Orb DID string by adding a <i>scheme</i> prefix to the CID.
          Please see <a href="#format">did:orb format</a> for more information about discovery schemes and examples.
          These DIDs are treated as equivalent to the canonical DID.

          An Orb resolution response MAY contain an <i>equivalentId</i> property that is populated with <i>orb-scheme-did</i> format DIDs.
        </section>

        <section class="normative">
          <h3>Discovery</h3>

          <section class="normative">
            <h4>Domain Endpoint Discovery</h4>

            <p>
              A client discovers a domain's endpoints for DID resolution and DID operations using a .well-known scheme [[RFC8615]].
              The domain declares its own endpoints for resolution and operations.
            </p>

            <pre class="example highlight" title="Client endpoint discovery (request)">
              GET /.well-known/did-orb HTTP/1.1
              Host: alice.example.com
              Accept-Encoding: gzip, deflate
            </pre>

            <p>
              When the discovery profile exists, an HTTP 200 status code is returned.
            </p>

            <pre class="example highlight" title="Client endpoint discovery (response)">
              HTTP/1.1 200 OK
              Date: Sat, 30 Jan 2021 18:31:58 GMT
              Content-Type: application/json; charset=utf-8
              Connection: keep-alive
              Access-Control-Allow-Origin: *

              {
                "resolutionEndpoint": "https://alice.example.com/sidetree/0.1/identifiers",
                "operationEndpoint": "https://alice.example.com/sidetree/0.1/operations"
              }
            </pre>
          </section>

          <section class="normative">
            <h4>Shared Resolution Domain</h4>

            <p>
              A shared domain may be used to enable a group of organizations to share resolution responsibilities.
              This model enables a resolution client to have increased confidence by validating a resolution result against multiple entities.
              A domain is a shared domain model when it declares its linked domains and an n-of-m policy in its well-known configuration.
              Linked domains indicate to clients that these domains have an synchronized (eventually consistent) relationship and can be used n-of-m for resolution.
              These domains and policy are fetched using a WebFinger [[RFC7033]] query.
              When using linked domain resolution, the client performs the following steps to obtain higher confidence in the resolution results:
            </p>
  
            <ol>
              <li>Lookup <i>n</i> from the <i>https://trustbloc.dev/ns/min-resolvers</i> property.</li>
              <li>Choose <i>n</i> of the links from the WebFinger result.</li>
              <li>Fetches the configurations at each chosen link using WebFinger.</li>
              <li>Validates that each well-known configuration has the same policy for <i>n</i> and that all of the chosen links are listed in the <i>n</i> fetched configurations.</li>
              <li>Resolve the DID at each of the <i>n</i> chosen links.</li>
              <li>Ensure that the DID resolution result matches (other than resolver-specific metadata such as timestamps).</li>
              <li>In case of a mismatch, additional links may need to be chosen until the client has <i>n</i> matches.</li>
            </ol>
  
            <pre class="example highlight" title="Client shared domain discovery (request)">
              GET /.well-known/did-orb HTTP/1.1
              Host: shared.example.com
              Accept-Encoding: gzip, deflate
            </pre>
  
            <p>
              When the discovery profile for the shared domain exists, an HTTP 200 status code is returned.
            </p>

            <pre class="example highlight" title="Client shared domain discovery (response)">
              HTTP/1.1 200 OK
              Date: Sat, 30 Jan 2021 18:31:58 GMT
              Content-Type: application/json; charset=utf-8
              Connection: keep-alive
              Access-Control-Allow-Origin: *
  
              {
                "resolutionEndpoint": "https://shared.example.com/sidetree/0.1/identifiers",
                "operationEndpoint": "https://shared.example.com/sidetree/0.1/operations"
              }
            </pre>

            <pre class="example highlight" title="Client shared domain discovery (request)">
              GET /.well-known/webfinger?resource=https%3A%2F%2Fshared.example.com%2Fsidetree%2F0.1%2Fidentifiers HTTP/1.1
              Host: shared.example.com
              Accept-Encoding: gzip, deflate
            </pre>
  
            <p>
              When the DID resolution capability exists, an HTTP 200 status code is returned.
            </p>

            <pre class="example highlight" title="Client shared domain discovery (response)">
              HTTP/1.1 200 OK
              Date: Sat, 30 Jan 2021 18:31:58 GMT
              Content-Type: application/jrd+json
              Connection: keep-alive
              Access-Control-Allow-Origin: *
  
              {
                "subject": "https://shared.example.com/sidetree/0.1/identifiers",
                "properties": {
                  "https://trustbloc.dev/ns/min-resolvers": 2
                },
                "links": [
                  {
                    "rel": "self",
                    "href": "https://shared.example.com/sidetree/0.1/identifiers"
                  },
                  {
                    "rel": "alternate",
                    "href": "https://charlie.example.com/sidetree/0.1/identifiers"
                  },
                  {
                    "rel": "alternate",
                    "href": "https://oscar.example.com/sidetree/0.1/identifiers"
                  },
                  {
                    "rel": "alternate",
                    "href": "https://mike.example.com/sidetree/0.1/identifiers"
                  }
                ]
              }
            </pre>            
          </section>
        </section>

        <section class="normative">
          <h3>Operation Origin and Policy</h3>
          
          <p>
          The DID controller declares their origin policy by setting the URI of their desired witness into the <i>anchorOrigin</i> property in the <i>Create</i> or <i>Replace</i> operation.
          </p>

          <p class="issue" title="Additional policy">
            TODO: In a followup revision, we might specify additional origin policy information.
          </p>
        </section>

        <section class="normative">
          <h3>Operation Anchoring Validity</h3>

          <p>
            The DID Controller includes their skew-adjusted current timestamp in the <i>anchorFrom</i> property of an operation's data object payload.
            To allow for clock skew, the DID Controller subtracts five minutes from their current timestamp.
            The timestamp is formatted as a [[RFC7519]] <i>NumericDate</i>.
          </p>

          <p>
            The DID Controller includes their skew-adjusted current timestamp in the <i>anchorUntil</i> property of an operation's data object payload.
            To allow for batching and clock skew, the DID Controller adds 25 minutes to their current timestamp.
            The timestamp is formatted as a [[RFC7519]] <i>NumericDate</i>.
          </p>

          <p>
            The delta range between <i>anchorFrom</i> and <i>anchorUntil</i> is 30 minutes.
          </p>

          <p class="issue" title="Protocol parameter for maximum time delta">
            TODO: In a followup revision, we will specify protocol parameters to constrain the delta range.
          </p>
        </section>          
    </section>

    <section class="normative">
        <h2>Server-to-Server APIs</h2>

        <p>
          An Orb Server exposes APIs for propagation, content-addressable storage, discovery, and witnessing.
        </p>

        <section class="normative">
          <h3>Vocabulary</h3>

          <section class="normative" id="anchorcredential">
            <h4>AnchorCredential</h4>

            <p>
              An Orb Transaction is represented as an <i>AnchorCredential</i>.
            </p>

            <pre class="example highlight" title="Orb transaction">
              {
                "@context": [
                  "https://www.w3.org/2018/credentials/v1",
                  "https://trustbloc.github.io/did-method-orb/contexts/anchor/v1",
                  "https://w3id.org/jws/v1"
                ],
                "id": "http://sally.example.com/transactions/bafkreihwsnuregceqh263vgdathcprnbvatyat6h6mu7ipjhhodcdbyhoy",
                "type": [
                  "VerifiableCredential",
                  "AnchorCredential"
                ],
                "issuer": "https://sally.example.com/services/orb",
                "issuanceDate": "2021-01-27T09:30:10Z",
                "credentialSubject": {
                  "operationCount": 1,
                  "coreIndex": "bafkreihwsnuregceqh263vgdathcprnbvatyat6h6mu7ipjhhodcdbyhoy",
                  "namespace": "did:orb",
                  "version": "1",
                  "previousAnchors": {
                    "EiA329wd6Aj36YRmp7NGkeB5ADnVt8ARdMZMPzfXsjwTJA": "bafkreibmrmenuxhgaomod4m26ds5ztdujxzhjobgvpsyl2v2ndcskq2iay",
                    "EiABk7KK58BVLHMataxgYZjTNbsHgtD8BtjF0tOWFV29rw": "bafkreibh3whnisud76knkv7z7ucbf3k2rs6knhvajernrdabdbfaomakli"
                  },
                  "type": "Anchor"
                },
                "proof": [{
                  "type": "JsonWebSignature2020",
                  "proofPurpose": "assertionMethod",
                  "created": "2021-01-27T09:30:00Z",
                  "verificationMethod": "did:example:abcd#key",
                  "domain": "sally.example.com",
                  "jws": "eyJ..."
                },
                {
                  "type": "JsonWebSignature2020",
                  "proofPurpose": "assertionMethod",
                  "created": "2021-01-27T09:30:05Z",
                  "verificationMethod": "did:example:abcd#key",
                  "domain": "https://witness1.example.com/ledgers/maple2021",
                  "jws": "eyJ..."
                },
                {
                  "type": "JsonWebSignature2020",
                  "proofPurpose": "assertionMethod",
                  "created": "2021-01-27T09:30:06Z",
                  "verificationMethod": "did:example:efgh#key",
                  "domain": "https://witness2.example.com/ledgers/spruce2021",
                  "jws": "eyJ..."
                }]                  
              }
            </pre>

            The Orb transaction is embedded within an Activity during propagation flows.
            The Activity includes information about the CAS.

            <pre class="example highlight" title="Orb transaction as an AnchorCredential wrapped in a Create Activity">
              {
                "@context": [
                  "https://www.w3.org/ns/activitystreams",
                  "https://trustbloc.github.io/did-method-orb/contexts/anchor/v1"
                ],
                "id": "https://sally.example.com/services/orb/activities/bafkreiatkubvbkdidscmqynkyls3iqawdqvthi7e6mbky2amuw3inxsi3y",
                "type": "Create",
                "actor": "https://sally.example.com/services/orb",
                "to": [
                  "https://sally.example.com/services/orb/followers",
                  "https://www.w3.org/ns/activitystreams#Public"
                ],
                "published": "2021-01-27T09:30:10Z",
                "target": {
                  "id":  "https://sally.example.com/cas/bafkreiatkubvbkdidscmqynkyls3iqawdqvthi7e6mbky2amuw3inxsi3y",
                  "type": "ContentAddressedStorage",
                  "cid":  "bafkreiatkubvbkdidscmqynkyls3iqawdqvthi7e6mbky2amuw3inxsi3y"
                },
                "object": {
                  "@context": [
                    "https://www.w3.org/2018/credentials/v1",
                    "https://trustbloc.github.io/did-method-orb/contexts/anchor/v1"
                  ],
                  "id": "http://sally.example.com/transactions/642bab75-76a4-4b5f-98bb-794467ad5891",
                  "type": [
                    "VerifiableCredential",
                    "AnchorCredential"
                  ],
                  "issuer": "https://sally.example.com/services/orb",
                  "issuanceDate": "2021-01-27T09:30:10Z",
                  "credentialSubject": {
                    "operationCount": 1,
                    "coreIndex": "bafkreihwsnuregceqh263vgdathcprnbvatyat6h6mu7ipjhhodcdbyhoy",
                    "namespace": "did:orb",
                    "version": "1",
                    "previousAnchors": {
                      "EiA329wd6Aj36YRmp7NGkeB5ADnVt8ARdMZMPzfXsjwTJA": "bafkreibmrmenuxhgaomod4m26ds5ztdujxzhjobgvpsyl2v2ndcskq2iay",
                      "EiABk7KK58BVLHMataxgYZjTNbsHgtD8BtjF0tOWFV29rw": "bafkreibh3whnisud76knkv7z7ucbf3k2rs6knhvajernrdabdbfaomakli"
                    },
                    "type": "Anchor"
                  },
                  "proof": [{}]
                }
              }
            </pre>

          </section>

        </section>

        <section class="normative">
          <h3>Service Discovery</h3>

          <p>
            An Orb Server discovers a domain's endpoints for the Orb actor using a .well-known scheme [[RFC8615]].
          </p>

          <pre class="example highlight" title="Client endpoint discovery (request)">
            GET /.well-known/did-orb HTTP/1.1
            Host: alice.example.com
            Accept-Encoding: gzip, deflate
          </pre>

          <p>
            When the discovery profile exists, an HTTP 200 status code is returned.
          </p>

          <pre class="example highlight" title="Client endpoint discovery (response)">
            HTTP/1.1 200 OK
            Date: Sat, 30 Jan 2021 18:31:58 GMT
            Content-Type: application/json; charset=utf-8
            Connection: keep-alive
            Access-Control-Allow-Origin: *

            {
              "resolutionEndpoint": "https://alice.example.com/sidetree/0.1/identifiers",
              "operationEndpoint": "https://alice.example.com/sidetree/0.1/operations",
              "serviceEndpoint": "https://alice.example.com/services/orb"
            }
          </pre>

          <p class="issue" title="nodeinfo">
            Add description for .well-known/nodeinfo.
          </p>
        </section>

        <section class="normative">
          <h3>ActivityPub</h3>

          <p>This section defines a minimal profile of [[ACTIVITYPUB]] that Orb Servers implement to participate in propagation flows.</p>

          <section class="normative">
            <h4>Actor (Discovery)</h4>
  
            <p>
              An <i>Actor</i> exposed by an Orb Server is capable of participating in propagation flows.
              ActivityPub endpoints are retrieved by performing an HTTP GET to the Actor endpoint.
              The Actor endpoint returns an <a href="https://www.w3.org/TR/activitypub/#actor-objects">Actor object</a>.
            </p>

            <pre class="example highlight" title="Actor retrieval">
              GET /services/orb HTTP/1.1
              Host: alice.example.com
              Accept: application/ld+json; profile="https://www.w3.org/ns/activitystreams"
              Accept-Encoding: gzip, deflate
            </pre>

            <p>
              When the service profile exists, an HTTP 200 status code is returned.
            </p>

            <pre class="example highlight" title="Successful Actor response">
              HTTP/1.1 200 OK
              Date: Wed, 27 Jan 2021 21:57:25 GMT
              Content-Type: application/jrd+json; charset=utf-8
              Connection: keep-alive
              Access-Control-Allow-Origin: *

              {
                "@context": [
                "https://www.w3.org/ns/activitystreams",
                "https://w3id.org/security/v1",
                "https://trustbloc.github.io/did-method-orb/contexts/anchor/v1"
                ],
                "id": "https://alice.example.com/services/orb",
                "type": "Service",
                "publicKey": {
                  "id": "https://alice.example.com/services/orb#main-key",
                  "owner": "https://alice.example.com/services/orb",
                  "publicKeyPem": "-----BEGIN PUBLIC KEY-----\nMIIBIjANBgkqhki....."
                },
                "inbox": "https://alice.example.com/services/orb/inbox",
                "outbox": "https://alice.example.com/services/orb/outbox",
                "followers": "https://alice.example.com/services/orb/followers",
                "following": "https://alice.example.com/services/orb/following",
                "witnesses": "https://alice.example.com/services/orb/witnesses",
                "witnessing": "https://alice.example.com/services/orb/witnessing",
                "likes": "https://alice.example.com/services/orb/likes",
                "liked": "https://alice.example.com/services/orb/liked",
                "shares": "https://alice.example.com/services/orb/shares"
              }
            </pre>

            <p class="issue" title="DID for service">
              TODO: Review handling of publicKey.
            </p>

          </section>

          <section class="normative">
            <h4>Delivery</h4>

            <p>
              Orb Servers use ActivityPub <a href="https://www.w3.org/TR/activitypub/#delivery">Delivery</a> mechanisms to propagate transactions and to request to follow other servers.
              A propagation or follow request is sent by performing an HTTP POST of an activity to an Orb Server's ActivityPub inbox endpoint.
            </p>

            <p>
              Orb Servers use HTTP Signatures [[HTTP-SIGNATURES]] when calling Server-to-Server APIs to create authenticated messages.
              The Orb Transaction objects are additionally signed using JSON-LD proofs [[LDPROOF]] from both the Writer server as well as Witness servers.
            </p>
          </section>

          <section class="normative">
            <h4>Collections</h3>

            <p>
              Please refer to [[ACTIVITYPUB]] <a href="https://www.w3.org/TR/activitypub/#collections">section 5</a> for general collections guidance.
              An Orb Server exposes:
            </p>

            <ul>
              <li>Outbox: provides an ordered collection of the activities published by the server.</li>
              <li>Inbox: provides an ordered collection of the activities received by the server.</li>
              <li>Followers: provides a collection (or ordered collection) of the other Orb servers following the server.</li>
              <li>Following: provides a collection (or ordered collection) of the other Orb servers the server is following.</li>
              <li>Witnesses: provides a collection (or ordered collection) of the other Orb servers that act as witnesses.</li>
              <li>Witnessing: provides a collection (or ordered collection) of the other Orb servers the server is witnessing.</li>
              <li>Likes: provides an ordered collection of the witness activities sent by the Orb server.</li>
              <li>Liked: provides an ordered collection of the witness activities received by the Orb server.</li>
              <li>Shares: provides an ordered collection of the propagation (announce) activities sent by the Orb server.</li>
            </ul>
          </section>
  
          <section class="normative">
            <h4>Create Activity</h4>
            <p>
              An Orb Server that creates a Transaction uses an <i>Create</i> activity to propagate that knowledge to its own followers.
              A transaction is propagated to another Orb Server by performing an HTTP POST of an <i>Create</i> activity containing an <i>AnchorCredential</i> to its ActivityPub inbox endpoint.
            </p>

            <pre class="example highlight" title="Propagating a new transaction (without an embedded anchor credential)">
              POST /services/orb/inbox HTTP/1.1
              Host: alice.example.com
              Content-Type: application/ld+json; profile="https://www.w3.org/ns/activitystreams"
              Accept-Encoding: gzip, deflate

              {
                "@context": [
                  "https://www.w3.org/ns/activitystreams",
                  "https://trustbloc.github.io/context/orb"
                ],
                "id": "https://sally.example.com/services/orb/activities/bafkreiatkubvbkdidscmqynkyls3iqawdqvthi7e6mbky2amuw3inxsi3y",
                "type": "Create",
                "actor": "https://sally.example.com/services/orb",
                "to": [
                  "https://sally.example.com/services/orb/followers",
                  "https://www.w3.org/ns/activitystreams#Public"
                ],
                "published": "2021-01-27T09:30:10Z",
                "object": {
                  "id": "http://sally.example.com/transactions/bafkreiatkubvbkdidscmqynkyls3iqawdqvthi7e6mbky2amuw3inxsi3y",
                  "type": "AnchorCredentialReference",
                  "target": {
                    "id":  "https://sally.example.com/cas/bafkreiatkubvbkdidscmqynkyls3iqawdqvthi7e6mbky2amuw3inxsi3y",
                    "type": "ContentAddressedStorage",
                    "cid":  "bafkreiatkubvbkdidscmqynkyls3iqawdqvthi7e6mbky2amuw3inxsi3y"
                  }
                }
              }
            </pre>

            <p>
              On success, HTTP status code 200 is returned.
            </p>

            <pre class="example highlight" title="Propagating a new transaction (with an embedded anchor credential)">
              POST /services/orb/inbox HTTP/1.1
              Host: alice.example.com
              Content-Type: application/ld+json; profile="https://www.w3.org/ns/activitystreams"
              Accept-Encoding: gzip, deflate

              {
                "@context": [
                  "https://www.w3.org/ns/activitystreams",
                  "https://trustbloc.github.io/did-method-orb/contexts/anchor/v1"
                ],
                "id": "https://sally.example.com/services/orb/activities/bafkreiatkubvbkdidscmqynkyls3iqawdqvthi7e6mbky2amuw3inxsi3y",
                "type": "Create",
                "actor": "https://sally.example.com/services/orb",
                "to": [
                  "https://sally.example.com/services/orb/followers",
                  "https://www.w3.org/ns/activitystreams#Public"
                ],
                "published": "2021-01-27T09:30:10Z",
                "target": {
                  "id":  "https://sally.example.com/cas/bafkreiatkubvbkdidscmqynkyls3iqawdqvthi7e6mbky2amuw3inxsi3y",
                  "type": "ContentAddressedStorage",
                  "cid":  "bafkreiatkubvbkdidscmqynkyls3iqawdqvthi7e6mbky2amuw3inxsi3y"
                },
                "object": {
                  "@context": [
                    "https://www.w3.org/2018/credentials/v1",
                    "https://trustbloc.github.io/did-method-orb/contexts/anchor/v1"
                  ],
                  "id": "http://sally.example.com/transactions/bafkreihwsnuregceqh263vgdathcprnbvatyat6h6mu7ipjhhodcdbyhoy",
                  "type": [
                    "VerifiableCredential",
                    "AnchorCredential"
                  ],
                  "issuer": "https://sally.example.com/services/orb",
                  "issuanceDate": "2021-01-27T09:30:10Z",
                  "credentialSubject": {
                    "operationCount": 1,
                    "coreIndex": "bafkreihwsnuregceqh263vgdathcprnbvatyat6h6mu7ipjhhodcdbyhoy",
                    "namespace": "did:orb",
                    "version": "1",
                    "previousAnchors": {
                      "EiA329wd6Aj36YRmp7NGkeB5ADnVt8ARdMZMPzfXsjwTJA": "bafkreibmrmenuxhgaomod4m26ds5ztdujxzhjobgvpsyl2v2ndcskq2iay",
                      "EiABk7KK58BVLHMataxgYZjTNbsHgtD8BtjF0tOWFV29rw": "bafkreibh3whnisud76knkv7z7ucbf3k2rs6knhvajernrdabdbfaomakli"
                    },
                    "type": "Anchor"
                  },
                  "proof": [{}]
                }
              }
            </pre>

            <p>
              On success, HTTP status code 200 is returned.
            </p>            
          </section>
  
          <section class="normative">
            <h4>Announce Activity</h4>
            <p>
              An Orb Server that learns about a new Transaction that was created by another Orb server uses an <i>Announce</i> activity to gossip that knowledge to its own followers.
              A transaction is forwarded to another Orb Server by performing an HTTP POST of an <i>Announce</i> activity containing an <i>AnchorCredential</i> to its ActivityPub inbox endpoint.
            </p>

            <pre class="example highlight" title="Propagating a forwarded transaction (without an embedded anchor credential)">
              POST /services/orb/inbox HTTP/1.1
              Host: alice.example.com
              Content-Type: application/ld+json; profile="https://www.w3.org/ns/activitystreams"
              Accept-Encoding: gzip, deflate

              {
                "@context": [
                  "https://www.w3.org/ns/activitystreams"
                ],
                "id": "https://sally.example.com/services/orb/activities/bafkreiatkubvbkdidscmqynkyls3iqawdqvthi7e6mbky2amuw3inxsi3y",
                "type": "Announce",
                "actor": "https://sally.example.com/services/orb",
                "to": [
                  "https://sally.example.com/services/orb/followers",
                  "https://www.w3.org/ns/activitystreams#Public"
                ],
                "published": "2021-01-27T09:30:10Z",
                "object": {
                  "type": "Collection",
                  "totalItems": 1,
                  "items": [
                    {
                      "@context": [
                        "https://trustbloc.github.io/did-method-orb/contexts/anchor/v1"
                      ],
                      "id": "http://sally.example.com/transactions/bafkreihwsnuregceqh263vgdathcprnbvatyat6h6mu7ipjhhodcdbyhoy",
                      "type": "AnchorCredentialReference",
                      "target": {
                        "id":  "https://sally.example.com/cas/bafkreiatkubvbkdidscmqynkyls3iqawdqvthi7e6mbky2amuw3inxsi3y",
                        "type": "ContentAddressedStorage",
                        "cid":  "bafkreiatkubvbkdidscmqynkyls3iqawdqvthi7e6mbky2amuw3inxsi3y"
                      }
                    }
                  ]
                }
              }
            </pre>

            <p>
              On success, HTTP status code 200 is returned.
            </p>

            <pre class="example highlight" title="Propagating a forwarded transaction (with an embedded anchor credential)">
              POST /services/orb/inbox HTTP/1.1
              Host: alice.example.com
              Content-Type: application/ld+json; profile="https://www.w3.org/ns/activitystreams"
              Accept-Encoding: gzip, deflate

              {
                "@context": [
                  "https://www.w3.org/ns/activitystreams",
                  "https://trustbloc.github.io/did-method-orb/contexts/anchor/v1"
                ],
                "id": "https://sally.example.com/services/orb/activities/bafkreiatkubvbkdidscmqynkyls3iqawdqvthi7e6mbky2amuw3inxsi3y",
                "type": "Announce",
                "actor": "https://sally.example.com/services/orb",
                "to": [
                  "https://sally.example.com/services/orb/followers",
                  "https://www.w3.org/ns/activitystreams#Public"
                ],
                "published": "2021-01-27T09:30:10Z",
                "object": {
                  "type": "Collection",
                  "totalItems": 1,
                  "items": [
                    {
                      "id": "http://sally.example.com/transactions/bafkreiatkubvbkdidscmqynkyls3iqawdqvthi7e6mbky2amuw3inxsi3y",
                      "type": "AnchorCredentialReference",
                      "target": {
                        "id":  "https://sally.example.com/cas/bafkreiatkubvbkdidscmqynkyls3iqawdqvthi7e6mbky2amuw3inxsi3y",
                        "type": "ContentAddressedStorage",
                        "cid":  "bafkreiatkubvbkdidscmqynkyls3iqawdqvthi7e6mbky2amuw3inxsi3y"
                      },
                      "object": {
                        "@context": [
                          "https://www.w3.org/2018/credentials/v1",
                          "https://trustbloc.github.io/did-method-orb/contexts/anchor/v1"
                        ],
                        "id": "http://sally.example.com/transactions/bafkreihwsnuregceqh263vgdathcprnbvatyat6h6mu7ipjhhodcdbyhoy",
                        "type": [
                          "VerifiableCredential",
                          "AnchorCredential"
                        ],
                        "issuer": "https://sally.example.com/services/orb",
                        "issuanceDate": "2021-01-27T09:30:10Z",
                        "credentialSubject": {
                          "operationCount": 1,
                          "coreIndex": "bafkreihwsnuregceqh263vgdathcprnbvatyat6h6mu7ipjhhodcdbyhoy",
                          "namespace": "did:orb",
                          "version": "1",
                          "previousAnchors": {
                            "EiA329wd6Aj36YRmp7NGkeB5ADnVt8ARdMZMPzfXsjwTJA": "bafkreibmrmenuxhgaomod4m26ds5ztdujxzhjobgvpsyl2v2ndcskq2iay",
                            "EiABk7KK58BVLHMataxgYZjTNbsHgtD8BtjF0tOWFV29rw": "bafkreibh3whnisud76knkv7z7ucbf3k2rs6knhvajernrdabdbfaomakli"
                          },
                          "type": "Anchor"
                        },
                        "proof": [{}]
                      }
                    }
                  ]
                }
              }
            </pre>

            <p>
              On success, HTTP status code 200 is returned.
            </p>
          </section>

          <section class="normative">
            <h4>Follow Activity</h4>
              <p>
                An Orb Server requests to follow another Orb Server by performing an HTTP POST of a <i>Follow</i> activity to its ActivityPub inbox endpoint.
                Refer to <a href="https://www.w3.org/TR/activitypub/#follow-activity-inbox">ActivityPub</a> for guidance. 
              </p>

              <pre class="example highlight" title="Request to follow an Orb Server">
                POST /services/orb/inbox HTTP/1.1
                Host: alice.example.com
                Content-Type: application/ld+json; profile="https://www.w3.org/ns/activitystreams"
                Accept-Encoding: gzip, deflate
  
                {
                  "@context": "https://www.w3.org/ns/activitystreams",
                  "id": "https://sally.example.com/activities/9052018f-9530-4aef-8a46-40bde9445a25",
                  "type": "Follow",
                  "to": "https://alice.example.com/services/orb",
                  "actor": "https://sally.example.com/services/orb"
                }
              </pre>

              <p>
                On success, HTTP status code 200 is returned.
              </p>
          </section>

          <section class="normative">
            <h4>Accept Follow Activity</h4>
              <p>
                An Orb Server accepts a Follow request by sending an HTTP POST of a <i>Accept</i> activity to the requesting Orb Server's ActivityPub inbox endpoint.
                Refer to <a href="https://www.w3.org/TR/activitypub/#accept-activity-inbox">ActivityPub</a> for guidance. 
              </p>

              <pre class="example highlight" title="Accept follow request from an Orb Server">
                POST /services/orb/inbox HTTP/1.1
                Host: sally.example.com
                Content-Type: application/ld+json; profile="https://www.w3.org/ns/activitystreams"
                Accept-Encoding: gzip, deflate
  
                {
                  "@context": "https://www.w3.org/ns/activitystreams",
                  "id": "https://alice.example.com/activities/e017e49a-6256-44a0-855d-5dc304ae67f7",
                  "to": "https://sally.example.com/services/orb",
                  "type": "Accept",
                  "actor": "https://alice.example.com/services/orb",
                  "object": {
                      "id": "https://sally.example.com/activities/9052018f-9530-4aef-8a46-40bde9445a25",
                      "to": "https://alice.example.com/services/orb",
                      "type": "Follow",
                      "actor": "https://sally.example.com/services/orb",
                  }                  
                }
              </pre>

              <p>
                On success, HTTP status code 200 is returned.
              </p>  
          </section>

          <section class="normative">
            <h4>Reject Follow Activity</h4>
              <p>
                An Orb Server rejects a Follow request by sending an HTTP POST of a <i>Reject</i> activity to the requesting Orb Server's ActivityPub inbox endpoint.
                Refer to <a href="https://www.w3.org/TR/activitypub/#reject-activity-inbox">ActivityPub</a> for guidance. 
              </p>

              <pre class="example highlight" title="Reject follow request from an Orb Server">
                POST /services/orb/inbox HTTP/1.1
                Host: sally.example.com
                Content-Type: application/ld+json; profile="https://www.w3.org/ns/activitystreams"
                Accept-Encoding: gzip, deflate
  
                {
                  "@context": "https://www.w3.org/ns/activitystreams",
                  "id": "https://alice.example.com/activities/e017e49a-6256-44a0-855d-5dc304ae67f7",
                  "to": "https://sally.example.com/services/orb",
                  "type": "Reject",
                  "actor": "https://alice.example.com/services/orb",
                  "object": {
                      "id": "https://sally.example.com/activities/9052018f-9530-4aef-8a46-40bde9445a25",
                      "to": "https://alice.example.com/services/orb",
                      "type": "Follow",
                      "actor": "https://sally.example.com/services/orb",
                  }                  
                }
              </pre>

              <p>
                On success, HTTP status code 200 is returned.
              </p>  
          </section>

        </section>

        <section class="normative" id='witness-activitypub'>
          <h3>Witness ActivityPub</h3>

          <section class="normative">
            <h4>InviteWitness Activity</h4>
            <p>
              An Orb Server invites another Orb Server to be a witness by performing an HTTP POST of an <i>InviteWitness</i> activity to its ActivityPub inbox endpoint.
            </p>

            <pre class="example highlight" title="Request to invite an Orb Server to be a witness">
                POST /services/orb/inbox HTTP/1.1
                Host: alice.example.com
                Content-Type: application/ld+json; profile="https://www.w3.org/ns/activitystreams"
                Accept-Encoding: gzip, deflate

                {
                  "@context": [
                    "https://www.w3.org/ns/activitystreams",
                    "https://trustbloc.github.io/did-method-orb/contexts/anchor/v1"
                  ],
                  "id": "https://sally.example.com/activities/7052018f-9530-3aef-8a46-20bde9445a21",
                  "type": "InviteWitness",
                  "to": "https://alice.example.com/services/orb",
                  "actor": "https://sally.example.com/services/orb"
                }
              </pre>

            <p>
              On success, HTTP status code 200 is returned.
            </p>
          </section>

          <section class="normative">
            <h4>Accept InviteWitness Activity</h4>
            <p>
              An Orb Server accepts an InviteWitness request by sending an HTTP POST of a <i>Accept</i> activity to the requesting Orb Server's ActivityPub inbox endpoint.
              Upon receiving this activity, the requesting Orb Server adds the actor to its collection of 'witnesses'.
              Refer to <a href="https://www.w3.org/TR/activitypub/#accept-activity-inbox">ActivityPub</a> for guidance.
            </p>

            <pre class="example highlight" title="Accept invite witness request from an Orb Server">
                POST /services/orb/inbox HTTP/1.1
                Host: sally.example.com
                Content-Type: application/ld+json; profile="https://www.w3.org/ns/activitystreams"
                Accept-Encoding: gzip, deflate

                {
                  "@context": [
                    "https://www.w3.org/ns/activitystreams",
                    "https://trustbloc.github.io/did-method-orb/contexts/anchor/v1"
                  ],
                  "id": "https://alice.example.com/activities/f017e49a-7256-44a0-255d-3dc304ae67f7",
                  "to": "https://sally.example.com/services/orb",
                  "type": "Accept",
                  "actor": "https://alice.example.com/services/orb",
                  "object": {
                      "id": "https://sally.example.com/activities/7052018f-9530-3aef-8a46-20bde9445a21",
                      "to": "https://alice.example.com/services/orb",
                      "type": "InviteWitness",
                      "actor": "https://sally.example.com/services/orb",
                  }
                }
              </pre>

            <p>
              On success, HTTP status code 200 is returned.
            </p>
          </section>

          <section class="normative">
            <h4>Reject InviteWitness Activity</h4>
            <p>
              An Orb Server rejects an InviteWitness request by sending an HTTP POST of a <i>Reject</i> activity to the requesting Orb Server's ActivityPub inbox endpoint.
              Refer to <a href="https://www.w3.org/TR/activitypub/#reject-activity-inbox">ActivityPub</a> for guidance.
            </p>

            <pre class="example highlight" title="Reject invite witness request from an Orb Server">
                POST /services/orb/inbox HTTP/1.1
                Host: sally.example.com
                Content-Type: application/ld+json; profile="https://www.w3.org/ns/activitystreams"
                Accept-Encoding: gzip, deflate

                {
                  "@context": [
                    "https://www.w3.org/ns/activitystreams",
                    "https://trustbloc.github.io/did-method-orb/contexts/anchor/v1"
                  ],
                  "id": "https://alice.example.com/activities/b013e49a-6256-24a0-855d-1dc304ar67f7",
                  "to": "https://sally.example.com/services/orb",
                  "type": "Reject",
                  "actor": "https://alice.example.com/services/orb",
                  "object": {
                      "id": "https://sally.example.com/activities/7052018f-9530-3aef-8a46-20bde9445a21",
                      "to": "https://alice.example.com/services/orb",
                      "type": "InviteWitness",
                      "actor": "https://sally.example.com/services/orb",
                  }
                }
              </pre>

            <p>
              On success, HTTP status code 200 is returned.
            </p>
          </section>

          <section class="normative">
            <h4>Offer Activity</h4>

            <p>
              An Orb Server sends a <i>preannouncement</i> of an Orb transaction using an <i>Offer</i> activity populated with an <i>AnchorCredential</i>.
              The <i>AnchorCredential</i> contains a Linked Data Proof from the Orb Writer server.
              The <i>Offer</i> activity also includes a <i>startTime</i> and <i>endTime</i> indicating the time period where the Orb Server will accept
              linked data proofs for inclusion into the Orb transaction.
              The <i>startTime</i> is the current timestamp for the Orb Server.
              The <i>endTime</i> is the cut-off timestamp for inclusion into the transaction.
            </p>

            <pre class="example highlight" title="Propagating a new transaction (with an embedded anchor credential)">
              POST /services/orb/inbox HTTP/1.1
              Host: witness1.example.com
              Content-Type: application/ld+json; profile="https://www.w3.org/ns/activitystreams"
              Accept-Encoding: gzip, deflate

              {
                "@context": [
                  "https://www.w3.org/ns/activitystreams"
                ],
                "id": "https://sally.example.com/services/orb/activities/bafkreiatkubvbkdidscmqynkyls3iqawdqvthi7e6mbky2amuw3inxsi3y",
                "type": "Offer",
                "actor": "https://sally.example.com/services/orb",
                "to": [
                  "https://sally.example.com/services/orb/witnesses",
                  "https://www.w3.org/ns/activitystreams#Public"
                ],
                "startTime": "2021-01-27T09:30:10Z",
                "endTime": "2021-01-27T09:31:10Z",
                "object": {
                  "@context": [
                    "https://www.w3.org/2018/credentials/v1",
                    "https://trustbloc.github.io/did-method-orb/contexts/anchor/v1"
                  ],
                  "id": "http://sally.example.com/transactions/bafkreihwsnuregceqh263vgdathcprnbvatyat6h6mu7ipjhhodcdbyhoy",
                  "type": [
                    "VerifiableCredential",
                    "AnchorCredential"
                  ],
                  "issuer": "https://sally.example.com/services/orb",
                  "issuanceDate": "2021-01-27T09:30:10Z",
                  "credentialSubject": {
                    "anchorString": "bafkreihwsnuregceqh263vgdathcprnbvatyat6h6mu7ipjhhodcdbyhoy",
                    "namespace": "did:orb",
                    "version": "1",
                    "previousTransactions": {
                      "EiA329wd6Aj36YRmp7NGkeB5ADnVt8ARdMZMPzfXsjwTJA": "bafkreibmrmenuxhgaomod4m26ds5ztdujxzhjobgvpsyl2v2ndcskq2iay",
                      "EiABk7KK58BVLHMataxgYZjTNbsHgtD8BtjF0tOWFV29rw": "bafkreibh3whnisud76knkv7z7ucbf3k2rs6knhvajernrdabdbfaomakli"
                    }
                  },
                  "proof": {}
                }
              }
            </pre>
          </section>

          <section class="normative">
            <h4>Like Activity</h4>

            <p>
              A Witness promises to include an Orb transaction into their ledger using a <i>Like</i> activity populated with its linked data proof
              of an <i>AnchorCredential</i> received in a previous <i>Offer</i>.
              A reference to the previously offered object is populated into the <i>object</i> field.
              The Witness includes the time range when the Orb transaction will become included into their ledger using <i>startTime</i> and <i>endTime</i> fields.
            </p>

            <pre class="example highlight" title="Providing a Linked Data Proof as a witness">
              POST /services/orb/inbox HTTP/1.1
              Host: witness1.example.com
              Content-Type: application/ld+json; profile="https://www.w3.org/ns/activitystreams"
              Accept-Encoding: gzip, deflate

              {
                "@context": [
                  "https://www.w3.org/ns/activitystreams"
                ],
                "id": "https://witness1.example.com/services/orb/likes/87bcd005-abb6-433d-a889-18bc1ce84988",
                "type": "Like",
                "actor": "https://witness1.example.com/services/orb",
                "to": [
                  "https://sally.example.com/services/orb",
                  "https://www.w3.org/ns/activitystreams#Public"
                ],
                "startTime": "2021-01-27T09:30:15Z",
                "endTime": "2021-01-27T09:40:15Z",
                "object": "http://sally.example.com/transactions/bafkreihwsnuregceqh263vgdathcprnbvatyat6h6mu7ipjhhodcdbyhoy",
                "result": {
                  "@context": [
                    "https://w3id.org/security/v1",
                    "https://w3id.org/jws/v1"
                  ],
                  "proof": {
                    "type": "JsonWebSignature2020",
                    "proofPurpose": "assertionMethod",
                    "created": "2021-01-27T09:30:15Z",
                    "verificationMethod": "did:example:abcd#key",
                    "domain": "https://witness1.example.com/ledgers/maple2021",
                    "jws": "eyJ..."  
                  }
                }
              }
            </pre>

            <p class="issue" title="Like vs Witness Activity">
              Review the appropriate Activity type in the above example.
            </p>

            <p class="issue" title="Include full credential in response">
              Review the whether or not we should embed the rest of the VC in the response.
            </p>

            <p>
              The Writer Orb Server assembles the linked data proofs into a proof chain to create the final <i>AnchorCredential</i>.
              The proof chain starts with the Writer's linked data proof followed by each witness's linked data proof.
              See <a href="#anchorcredential"></a>.
            </p>

          </section>
        </section>

        <section class="normative">
          <h3>WebFinger</h3>

          <p>
            WebFinger [[RFC7033]] is used to discover endpoints for Orb service and resource URIs.
          </p>

          <p>The following example retrieves endpoints for a service named orb at alice.example.com.</p>

          <pre class="example highlight" title="Discover endpoints for an Orb service (request).">
            GET /.well-known/webfinger?resource=https%3A%2F%2Falice.example.com%2Fservices%2Forb HTTP/1.1
            Host: alice.example.com
            Accept-Encoding: gzip, deflate
          </pre>

          <p>
            When the resource exists, an HTTP 200 status code is returned.
          </p>

          <pre class="example highlight" title="Discover endpoints for an Orb service (response).">
            HTTP/1.1 200 OK
            Date: Sat, 30 Jan 2021 13:20:11 GMT
            Content-Type: application/jrd+json
            Connection: keep-alive
            Access-Control-Allow-Origin: *

            {
              "subject": "https://alice.example.com/services/orb",
              "aliases": [
                "https://alice.example.com/@orb",
                "https://alice.example.com/services/orb"
              ],
              "links": [
                {
                  "rel": "self",
                  "type": "application/activity+json",
                  "href": "https://alice.example.com/services/orb"
                }
              ]
            }
          </pre>

          <p>
            Aliases for a resource can also be queried. For example, the following is a request for orb@alice.example.com.
            This request has the same response as the prior example.
          </p>

          <pre class="example highlight" title="Discover endpoints for an Orb service using service alias.">
            GET /.well-known/webfinger?resource=acct%orb%40alice.example.com HTTP/1.1
            Host: alice.example.com
            Accept-Encoding: gzip, deflate
          </pre>

          <p>
            WebFinger is also used to query for resource endpoint discovery.
          </p>

          <pre class="example highlight" title="Discover endpoints for an Orb transaction (request).">
            GET /.well-known/webfinger?resource=https%3A%2F%2Fsally.example.com%2Ftransactions%2Fbafkreiatkubvbkdidscmqynkyls3iqawdqvthi7e6mbky2amuw3inxsi3y HTTP/1.1
            Host: sally.example.com
            Accept-Encoding: gzip, deflate
          </pre>

          <p>
            When the resource exists, an HTTP 200 status code is returned.
          </p>

          <pre class="example highlight" title="Discover endpoints for an Orb transaction (response).">
            HTTP/1.1 200 OK
            Date: Sat, 30 Jan 2021 13:20:11 GMT
            Content-Type: application/jrd+json
            Connection: keep-alive
            Access-Control-Allow-Origin: *

            {
              "subject": "https://sally.example.com/transactions/bafkreiatkubvbkdidscmqynkyls3iqawdqvthi7e6mbky2amuw3inxsi3y",
              "links": [
                {
                  "rel": "self",
                  "type": "application/ld+json",
                  "href": "https://sally.example.com/transactions/bafkreiatkubvbkdidscmqynkyls3iqawdqvthi7e6mbky2amuw3inxsi3y"
                },
                {
                  "rel": "working-copy",
                  "type": "application/ld+json",
                  "href": "https://sally.example.com/cas/bafkreiatkubvbkdidscmqynkyls3iqawdqvthi7e6mbky2amuw3inxsi3y"
                },
                {
                  "rel": "working-copy",
                  "type": "application/ld+json",
                  "href": "https://replica.example.com/cas/bafkreiatkubvbkdidscmqynkyls3iqawdqvthi7e6mbky2amuw3inxsi3y"
                }
              ]
            }
          </pre>

          <p class="issue" title="Link relations">
            Review the appropriate link relations in the above example.
          </p>

        </section>

        <section class="normative">
          <h3>Content Addressable Storage</h3>

          <p>
            Orb Servers expose Orb and Sidetree content as content-addressable objects.
            These objects can be retrieved through Web endpoints or discovered using a Distributed Hash Table (DHT).
          </p>

          <section class="normative">
            <h4>WebCAS</h4>
            <p>
              Orb Servers expose a CAS endpoint to provide access to Orb and Sidetree content.
              Resources are retrieved by sending a HTTP GET to the Server's CAS path with the content identifier [[CID]] of the resource.
            </p>

            <pre class="example highlight" title="Retrieve content from WebCAS (request).">
              GET /cas/bafkreiatkubvbkdidscmqynkyls3iqawdqvthi7e6mbky2amuw3inxsi3y HTTP/1.1
              Host: sally.example.com
              Accept-Encoding: gzip, deflate
            </pre>

            <p>
              When the content exists, an HTTP 200 status code is returned.
            </p>

            <pre class="example highlight" title="Retrieve content from WebCAS (response).">
              HTTP/1.1 200 OK
              Date: Sat, 30 Jan 2021 13:20:11 GMT
              Content-Type: text/plain; charset=utf-8
              Connection: keep-alive
              Access-Control-Allow-Origin: *

              {
                "@context": [
                  "https://www.w3.org/2018/credentials/v1",
                  "https://trustbloc.github.io/did-method-orb/contexts/anchor/v1",
                  "https://w3id.org/jws/v1"
                ],
                "id": "http://sally.example.com/transactions/bafkreihwsnuregceqh263vgdathcprnbvatyat6h6mu7ipjhhodcdbyhoy",
                "type": [
                  "VerifiableCredential",
                  "AnchorCredential"
                ],
                "issuer": "https://sally.example.com/services/orb",
                "issuanceDate": "2021-01-27T09:30:10Z",
                "credentialSubject": {
                  "operationCount": 1,
                  "coreIndex": "bafkreihwsnuregceqh263vgdathcprnbvatyat6h6mu7ipjhhodcdbyhoy",
                  "namespace": "did:orb",
                  "version": "1",
                  "previousAnchors": {
                    "EiA329wd6Aj36YRmp7NGkeB5ADnVt8ARdMZMPzfXsjwTJA": "bafkreibmrmenuxhgaomod4m26ds5ztdujxzhjobgvpsyl2v2ndcskq2iay",
                    "EiABk7KK58BVLHMataxgYZjTNbsHgtD8BtjF0tOWFV29rw": "bafkreibh3whnisud76knkv7z7ucbf3k2rs6knhvajernrdabdbfaomakli"
                  },
                  "type": "Anchor"
                },
                "proof": [{}]                  
              }
            </pre>
          </section>

          <section class="normative">
            <h4>Distributed Hash Table</h4>
  
            <p class="issue" title="An Orb DHT profile may be considered in the future">
              We currently enable usage of the IPFS DHT.
              In the future, we may want to additionally consider an Orb-specific profile to limit usage to VDRs.
            </p>
          </section>
  
        </section>

      </section>

    <section class="normative">
      <h2>Witness Ledger</h2>

      <section class="normative">
        <h3>Ledger Types</h3>

        <table class="simple">
          <thead>
            <tr>
              <th>Name</th>
              <th>Type Code</th>
              <th>Specification</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>Verifiable Credential Transparency</td>
              <td>vct-v1</td>
              <td><a href="#vct-v1"></a></td>
            </tr>
          </tbody>
        </table>
      </section>

      <section class="normative">
        <h3>Discovery</h3>

        <p>
          The linked data proof includes a domain property that indicates the ledger that promises to include an Orb transaction.
          The type of the ledger can be determined using the WebFinger protocol [[RFC7033]] along with known replicas, if any.
          The replica links have the relation field set to <i>alternate</i>.
        </p>

        <pre class="example highlight" title="Ledger discovery (request)">
          GET /.well-known/webfinger?resource=https%3A%2F%2Fwitness1.example.com%2Fledgers%2Fmaple2021 HTTP/1.1
          Host: witness1.example.com
          Accept-Encoding: gzip, deflate
        </pre>

        <p>
          When the ledger exists, an HTTP 200 status code is returned.
        </p>

        <pre class="example highlight" title="Client shared domain discovery (response)">
          HTTP/1.1 200 OK
          Date: Sat, 30 Jan 2021 18:31:58 GMT
          Content-Type: application/jrd+json
          Connection: keep-alive
          Access-Control-Allow-Origin: *

          {
            "subject": "https://witness1.example.com/ledgers/maple2021",
            "properties": {
              "https://trustbloc.dev/ns/ledger-type": "vct-v1"
            },
            "links": [
              {
                "rel": "self",
                "href": "https://witness1.example.com/ledgers/maple2021"
              },
              {
                "rel": "alternate",
                "href": "https://replica.example.com/ledgers/maple2021"
              }
            ]
          }
        </pre>     

      </section>

      <section class="normative" id="vct-v1">
        <h3>Verifiable Credential Transparency (VCT)</h3>

        <p>
          The Verifiable Credential Transparency (VCT) Witness ledger is based on on certificate transparency [[RFC6962]].
          The Anchor Credentials are included into VCT ledgers (as append-only Merkle Tree logs).
          VCT ledgers may be named to enable rollover.
        </p>

        <p>
          We extend [[RFC6962]] to include Verifiable Credential (VC) [[VC-DATA-MODEL]] objects.
          The following subsections describe the endpoints and the additional VC type for the Merkle Tree.
        </p>

        <section class="normative">
          <h4>Add Verifiable Credential</h4>
          <p>
            Orb <i>AnchorCredentials</i> are added using the process described in <a href='#witness-activitypub'></a>, as required by Orb.
          </p>
        </section>
       
        <section class="normative">
          <h4>Latest Signed Tree Head</h4>
          <p>
            The <i>Retrieve Latest Signed Tree Head</i> endpoint is described in <a href="https://tools.ietf.org/html/rfc6962#section-4.3">RFC6962</a>.
            In this example, a signed tree head is requested from a ledger named <i>maple2021</i>.
          </p>

          <pre class="example highlight" title="Retrieve signed tree head (request).">
            GET /ledgers/maple2021/ct/v1/get-sth HTTP/1.1
            Host: witness1.example.com
            Accept-Encoding: gzip, deflate
          </pre>

          <pre class="example highlight" title="Retrieve signed tree head (response).">
            HTTP/1.1 200 OK
            Date: Sat, 30 Jan 2021 13:20:11 GMT
            Content-Type: application/json
            Connection: keep-alive
            Access-Control-Allow-Origin: *

            {
              "tree_size": 100,
              "timestamp": 1612097791,
              "sha256_root_hash": "qOK55eWhQ96DmRbAsHTridM1BrxZtqJAW2uF0ceQcTo=",
              "tree_head_signature": "6UIXmSf8Pg9jY6e8DUPguEW3sl0HxX0fckMnP5ckUchcnsjlXee0722AV4RL1+xNEGVX/poCKu/wPH9teprMyw",
            }
          </pre>
        </section>

        <section class="normative">
          <h4>Merkle Consistency Proof</h4>

          <p>
            The <i>Retrieve Merkle Consistency Proof between Two Signed Tree Heads</i> endpoint is described in <a href="https://tools.ietf.org/html/rfc6962#section-4.4">RFC6962</a>.
          </p>
        </section>

        <section class="normative">
          <h4>Merkle Audit Proof</h4>

          <p>
            The <i>Retrieve Merkle Audit Proof from Log by Leaf Hash</i> endpoint is described in <a href="https://tools.ietf.org/html/rfc6962#section-4.5">RFC6962</a>.
          </p>
        </section>

        <section class="normative">
          <h4>Retrieve Entries</h4>

          <p>
            The <i>Retrieve Entries from Log</i> endpoint is described in <a href="https://tools.ietf.org/html/rfc6962#section-4.6">RFC6962</a>.
          </p>

          <p>
            extra_data: We extend the entry types to include verifiable credentials.
            In the case of a VC type, <i>extra_data</i> contains the verifiable credential.
          </p>
        </section>

        <section class="normative">
          <h4>Acceptable Issuers</h4>

          <p class="issue" title="Equivalent of accepted root certificates">
            TODO: In a followup revision, we may specify an equivalent endpoint for [[RFC6962]] <a href="https://tools.ietf.org/html/rfc6962#section-4.7">section 4.7</a>.
          </p>
        </section>

        <section class="normative">
          <h4>Entry and Audit Proof</h4>

          <p>
            The <i>Retrieve Entry+Merkle Audit Proof</i> endpoint is described in <a href="https://tools.ietf.org/html/rfc6962#section-4.8">RFC6962</a>.
          </p>

          <p>
            extra_data: We extend the entry types to include verifiable credentials.
            In the case of a VC type, <i>extra_data</i> contains the verifiable credential.
          </p>
        </section>

        <section class="normative">
          <h4>Merkle Tree and Entries</h4>

          <p>
            We extend the <i>LogEntryType</i> enumeration described in <a href="https://tools.ietf.org/html/rfc6962#section-3.1">RFC6962</a> to include <i>vc_entry</i>.
            The MerkleTree structure described in <a href="https://tools.ietf.org/html/rfc6962#section-3.4">RFC6962</a> is extended to include a <i>vc_entry</i> case.
            In the case of <i>vc_entry</i>, the <i>signed_entry</i> field of the Merkle Tree contains a Verifiable Credential.
          </p>

        </section>

        <section class="normative">
          <h4>Monitoring and Auditing</h4>

          <p>Please refer to [[RFC6962]] <a href="<a href="https://tools.ietf.org/html/rfc6962#section-5.3">section 5.3</a> and <a href="<a href="https://tools.ietf.org/html/rfc6962#section-5.4">section 5.4</a>.</p>
        </section>
      </section>
    </section>
      
    <section class="informative">
        <h2>Security Considerations</h2>

        <p>
          Security considerations are provided in conformance with [[RFC3552]] section 5 and [[DID-CORE]].
        </p>

        <p>
          As Orb is an extension of [[SIDETREE]], we inherit the security properties of <i>self certifying</i> DIDs and the Sidetree operation chains:
        </p>

        <ul>
          <li>Orb DIDs are unique since the Unique Suffix is bound to the DID's initial state including inception keys.</li>
          <li>DID operations that modify the DID's state are authenticated and integrity protected by JSON Web Signatures [[RFC7515]] and the [[SIDETREE]] commitment scheme.</li>
          <li>Update and recovery private keys (for signing operations) are to be held secret.</li>
          <li>Commitment keys are to be held secret prior to revealing in the subsequent operation.</li>
        </ul>

        <p>
          As Orb is a DID method based on gossip propagation, each Orb Server holds a subset of the overall transaction graph.
        </p>

        <ul>
          <li>Orb servers become aware of larger number of transactions announcements based on the number of other Servers they follow.</li>
          <li>
            Some Orb servers may gain <i>super node</i> characteristics when they follow and replicate large portions of the graph.
            Systems that follow these highly connected nodes also receive larger number of announcements.
          </li>
          <li>As the network is decentralized, Orb servers are recommended to replicate the graph structures and files that they depend upon.</li>
          <li>
            As with Sidetree, some Orb servers may choose to act as <i>light nodes</i> where files are retrieved on-demand to conserve storage.
            These nodes may lose access to files if they become unavailable in the network.
          </li>
          <li>
            An Orb server may request the latest transaction for a DID from their associated Witness to determine if they are missing the latest parts of the graph.
            Different Orb servers have different confidence levels on holding the most recent updates based on the Orb servers they are following and Witnesses 
            they are monitoring.
          </li>
        </ul>

        <p>
          The following table summarizes the security considerations required by [[RFC3552]].
        </p>

        <table class="simple">
          <thead>
            <tr>
              <th>Attack</th>
              <th>In-Scope</th>
              <th>Susceptible</th>
              <th>Mitigations and Notes</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>Eavesdropping</td>
              <td>No</td>
              <td>No</td>
              <td>
                <ul>
                  <li>Eavesdropping attacks are not applicable since the VDR is open by design.</li>
                </ul>
              </td>
            </tr>
            <tr>
              <td>Replay</td>
              <td>Yes</td>
              <td>No</td>
              <td>
                <ul>
                  <li>
                    Each Orb transaction represents a unique node in the transaction graph.
                    As transactions are propagated in a gossip manner, servers should de-duplicate and not
                    announce transactions multiple times to its followers.
                  </li>
                  <li>
                    If a transaction is received multiple times by an Orb server, the Orb server is not affected
                    as transactions are simply announcements of immutable operations.
                    Duplicated transactions have no effect and are ignored.
                  </li>
                  <li>
                    The Orb specification contains rules for choosing one active branch in the DID operation chain.
                    Duplicated operations are detected by their position in the Sidetree commit/reveal chain.
                    As Orb Servers only choose one active branch for each DID, duplicated operations have no effect and are ignored.
                  </li>
                </ul>
              </td>
            </tr>
            <tr>
              <td>Message Insertion</td>
              <td>Yes</td>
              <td>No</td>
              <td>
                <ul>
                  <li>
                    Orb transactions contain immutable references to their parent transactions.
                    Inserted messages have no effect and are ignored.
                  </li>
                  <li>
                    DID operation are chained using the Sidetree commit/reveal scheme.
                    Inserted messages have no effect and are ignored.
                  </li>
                </ul>
              </td>
            </tr>
            <tr>
              <td>Deletion</td>
              <td>Yes</td>
              <td>Mitigated</td>
              <td>
                <ul>
                  <li>
                    The Orb VDR is replicable across Orb Servers and CAS networks.
                    However, if all copies of a VDR object are deleted, the associated DIDs become unresolvable.
                  </li>
                  <li>
                    Orb servers should use an appropriate backup strategy and replicate VDR objects from the rest of the ecosystem.
                  </li>
                </ul>
              </td>
            </tr>
            <tr>
              <td>Modification</td>
              <td>Yes</td>
              <td>No</td>
              <td>
                <ul>
                  <li>
                    VDR objects are stored in content-addressable storage and are immutable by design.
                  </li>
                  <li>
                    The DID operation chain is tamper-resistant as it leverages the Sidetree commit/reveal scheme and signed operations.
                  </li>
                  <li>
                    As we anticipate that Orb Servers leverage caches to reduce processing burdens, those servers and caches should be appropriately secured.
                  </li>
                </ul>
              </td>
            </tr>
            <tr>
              <td>Man-in-the-Middle</td>
              <td>Yes</td>
              <td>Mitigated</td>
              <td>
                <ul>
                  <li>
                    It is recommended to use TLS when calling the HTTP(S) Resolution API.
                  </li>
                </ul>
              </td>
            </tr>
            <tr>
              <td>Denial of Service</td>
              <td>Yes</td>
              <td>Mitigated</td>
              <td>
                <ul>
                  <li>
                    An attacker may cause DoS issues by sending spam transaction announcements, in an effort to overwhelm storage and processing.
                    Propagated transaction announcements are signed so that attacking systems can become ignored.
                  </li>
                </ul>
              </td>
            </tr>
          </tbody>            
        </table>
    </section>
        
    <section class="informative">
      <h2>Privacy Considerations</h2>

      <p>
        Please refer to [[DID-CORE]] <a href="https://www.w3.org/TR/did-core/#privacy-considerations">Privacy Considerations</a>.
        The following table summarizes privacy considerations from [[RFC6973]] section 5:
      </p>

      <table class="simple">
        <thead>
          <tr>
            <th>Threat</th>
            <th>Comments</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>
              Surveillance
            </td>
            <td>
              Orb creates a decentralized and replicated VDR. Interconnected systems should be expected to observe DID update operations.
              For DID resolution, the opportunities for surveillance can be mitigated where an RP is running their own highly interconnected server.
              The usage of batches also brings advantages as operations from many DIDs become intermingled into files that are being requested.
              A Witness Server may also have surveillance opportunities when other systems inquire for the latest transaction for a particular DID.
              These opportunities are mitigated for highly interconnected servers that already have confidence in having the latest transactions,
              either from propagations or from monitoring and replicating Witness ledgers. 
            </td>
          </tr>
          <tr>
            <td>
              Stored data compromise
            </td>
            <td>
              Orb creates a decentralized and replicated VDR. Interconnected systems should be expected to observe DID update operations.
            </td>
          </tr>
          <tr>
            <td>
              Unsolicited traffic
            </td>
            <td>
              The DID controller is responsible for choosing which endpoints to include within their DIDs.
            </td>
          </tr>
          <tr>
            <td>
              Misattribution
            </td>
            <td>
              Orb uses <i>self certifying</i> DIDs - the DID controller is fully responsible for the changes to their DIDs.
            </td>
          </tr>
          <tr>
            <td>
              Correlation
            </td>
            <td>
              Orb DID Suffixes are not inherently correlatable since the Unique Suffix is bound to the DID's initial state including inception keys.
              Please refer to [[DID-CORE]] for additional guidance.
            </td>
          </tr>
          <tr>
            <td>
              Identification
            </td>
            <td>
              Orb DID Suffixes are not inherently identifiable since the Unique Suffix is bound to the DID's initial state including inception keys.
              Please refer to [[DID-CORE]] for additional guidance.
            </td>
          </tr>
          <tr>
            <td>
              Secondary use
            </td>
            <td>
              The DID operations applied by a DID controller map to their usage of constructing a DID document.
            </td>
          </tr>
          <tr>
            <td>
              Disclosure
            </td>
            <td>
              The DID controller is responsible for the operations applied to their DID documents.
            </td>
          </tr>
          <tr>
            <td>
              Exclusion
            </td>
            <td>
              The DID method specifies a decentralized and replicable VDR. Increasing the connections between systems 
              and using a replicable VDR strategy mitigates against exclusion.
            </td>
          </tr>
        </tbody>      
      </table>

      <p>
        As Orb enables Servers to interconnect as much as they choose and is agnostic to underlying ledgers,
        the availability of data can vary based on those choices.
      </p>
    </section>

    <section id='conformance'>
      <!-- This section is filled automatically by ReSpec. -->
    </section>
  </body>
</html>