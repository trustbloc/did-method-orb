<!DOCTYPE html>
<html>
  <head>
    <title>The did:orb Method v0.1</title>
    <meta charset='utf-8'>
    <script src='https://www.w3.org/Tools/respec/respec-w3c' async class='remove'></script>
    <script class='remove'>
      var respecConfig = {
        specStatus: "unofficial",
        subtitle: "A DID Method for a fediverse of interconnected nodes and witnesses",
        editors: [{
          name: "Troy Ronda", url: "https://www.linkedin.com/in/troyronda/",
          company: "SecureKey", companyURL: "https://securekey.com/"
        }],
        github: "https://github.com/trustbloc/did-method-orb",
        localBiblio: {
          SIDETREE: {
            title: "Sidetree",
            href: "https://identity.foundation/sidetree/spec/",
            publisher: "Decentralized Identity Foundation",
            status: "Editorâ€™s Draft"
          }
        }
      };
    </script>
  </head>
  <body>
    <section id='abstract'>
      <p>
        Orb is a decentralized identifier (DID) method based on a federated and replicated
        <a href="https://www.w3.org/TR/did-core/#dfn-verifiable-data-registry">Verifiable Data Registry</a> (VDR).
        The decentralized network consists of Orb servers that write, monitor, witness, and propagate batches of DID operations.
        The batches form a graph that is propagated and replicated between the servers as content-addressable objects.
        These content-addressable objects can be located via both domain and distributed hash table (DHT) mechanisms.
        Each Orb witness server observes a subset of batches in the graph and includes them in their ledgers (as append-only Merkle Tree logs).
        The servers coordinate by propagating batches of DID operations and by monitoring the applicable witness servers' ledgers.
        The Orb servers form a decentralized network without reliance on a common blockchain for coordination.
      </p>

      <p>
        This document specifies the Orb DID Method along with a data model and rules for representing a graph of batches, 
        the Orb server API, a registry of protocol versions and parameters,
        an [[[ACTIVITYSTREAMS-CORE]]] vocabulary and an [[[ACTIVITYPUB]]] profile for propagating batches,
        a [[[RFC7033]]] profile for discovering endpoints, a [[[SIDETREE]]] protocol profile for encoding DID operations,
        and a [[[RFC6962]]] profile for witness ledgers.
      </p>
    </section>
    <section id='sotd'>
      <p>
      </p>
    </section>
    
    <section class="informative">
        <h2>Introduction</h2>
        <p>
          The Orb DID method enables users or entities to create <a href="https://identity.foundation/sidetree/spec/#did-uri-composition">self certifying</a>
          decentralized identifiers (DIDs) that are propagated across a decentralized network without reliance on a common blockchain for coordination.
          Decentralized identifiers [[DID-CORE]] are a fundamental building block to enable persons and entities to prove that they control an identifier
          that is attached to digital objects such as Verifiable Credentials [[VC-DATA-MODEL]].
        </p>

        <p>
          Systems that rely on <i>self certifying</i> DIDs need a
          mechanism to propagate the ordered updates to DID documents from the server writing operations to their DID resolver.
          As an example, operations can be distributed via a content-addressable network (such as <a href="https://ipfs.io">IPFS</a>)
          and announced on a public blockchain (such as <a href="https://bitcoin.org">Bitcoin</a>) or a permissioned blockchain
          (such as <a href="https://www.hyperledger.org/use/fabric">Hyperledger Fabric</a>). This DID method, instead, makes use of
          decentralized federation protocols to propagate announcements and replicate content in a <a href="https://en.wikipedia.org/wiki/Gossip_protocol">gossip manner</a>.
          By using a decentralized federation mechanism, we have no need to choose a common blockchain nor rely on a consortium's
          <a href="https://en.wikipedia.org/wiki/Distributed_ledger">distributed ledger</a> (DLT) for coordination.
          Orb has the ability to enable use cases where a public blockchain is not acceptable to stakeholders and also avoids lock-in to a single DLT. 
        </p>

        <p>
          As operations on DIDs can be originated by different writers in a decentralized network, it is also beneficial to enable a mechanism for determining
          the latest operations for a particular suffix. For example, when all DID operations are announced by the same blockchain, the other systems can
          monitor that blockchain for the latest operations. These blockchains can also provide relative timing in cases of 
          <a href="https://identity.foundation/sidetree/spec/#late-publishing">late publishing</a>. This DID method, instead, makes use of independent witness ledgers
          that the DID owner can associate with their DID. These witness ledgers can be monitored as an additional propagation source and proofs from these ledgers can
          also provide relative timing confidence in cases of late publishing. Rather than being a global chain of all operation announcements, these ledgers contain
          a subset of the announcements that propagate through the decentralized federation protocols.
        </p>
          
        <p>
          The property of self certifying DIDs is obtained due to Orb being an extension of the [[[SIDETREE]]] protocol.
          By using the Sidetree protocol, the DID controller forms their own verifiable chain of patches from inception to the current state of the DID document.
          These verifiable chains are included into larger batches by one of the independent Orb servers and encoded as content-addressable objects. We also
          inherit the scalability properties of the Sidetree protocol batch strategy.
        </p>

        <p>
          Our motivation for the Orb DID method is to enable many independent organizations to create <a href="https://www.w3.org/TR/did-core/#dfn-verifiable-data-registry">
          Verifiable Data Registries</a> (VDRs) that can become connected over time.
          In designing Orb, we have the goal to enable these VDRs to interconnect into a decentralized network without the need to choose a common public
          blockchain or to rely on special-purpose consortiums to form (and remain in operation). By using decentralized federation protocols and witness ledgers, 
          we enable <i>self-certifying</i> DIDs even in use cases where leveraging a public blockchain or a consortium DLT is not acceptable to stakeholders.
          Orb enables a federated, replicated and scalable VDR based on a decentralized network for propagating, witnessing and replicating changes to DID documents.
        </p>

    </section>

    <section class="normative">
      <h2 id="format">Concepts</h2>

      <p>
        Orb uses a propagation model where servers announce transactions to other servers that are following them.
        In general, <i>Orb Servers</i> have the capability to propagate transactions and replicate Orb 
        <a href="https://www.w3.org/TR/did-core/#dfn-verifiable-data-registry"> Verifiable Data Registries</a> (VDRs).
        Beyond propagation and replication, there are three primary <i>Orb Server</i> roles in the transaction flow:
      </p>
      
      <ul>
        <li>Writer: Accepts operations from DID controllers to update their DIDs, batches operations, and creates an Orb transaction from each batch.</li>
        <li>Witness: Provides decentralized timestamping and partial ledger histories for Orb transactions. Accepts <i>preannouncements</i> of Orb transactions from Writers.</li>
        <li>Resolver: Responds to Requesting Party (RP) requests for DID resolution.</li>
      </ul>

      <figure>
        <img src="diagrams/flow-model.svg" style="max-width: 50%;"/>
        <figcaption>
          Orb transaction propagation model
        </figcaption>
      </figure>

      <p class="issue" title="Operations, transaction, and witness ledgers">
        TODO: diagram and description relating DID operations to Orb transactions and witness ledgers.
      </p>

      <p class="issue" title="Discovery, replication, monitoring">
        TODO: diagram and description for discovery, replication, monitoring, and DHTs.
      </p>

      <section class="normative">
        <h3>Self Certifying Decentralized Identifiers</h3>

        <p>
          Orb DIDs are <i>self certifying</i>.
          The data structure that encodes the ordered updates to a DID document form their own verifiable chain from inception to the current state of the DID document.
          We inherit this property due to our usage of the [[[SIDETREE]]] protocol for encoding the DID document updates.
        </p>
      </section>

      <section class="normative">
        <h3>Propagation via Decentralized Federation</h3>

        <p>
          Orb makes use of decentralized federation protocols to propagate announcements and replicate content in a
          <a href="https://en.wikipedia.org/wiki/Gossip_protocol">gossip manner</a>. We use [[[ACTIVITYSTREAMS-CORE]]] and [[[ACTIVITYPUB]]].
          In later sections, we describe the vocabulary and profile for using these protocols in Orb.
        </p>

        <p>
          Orb does not rely on public blockchains nor DLTs to coordinate - there is no need for network consensus. Instead, we rely on
          self certifying DIDs being propagated and the ability to replicate VDRs in a gossip manner. 
        </p>
      </section>

      <section class="normative">
        <h3>DID Updates Are Batched</h3>

        <p>
          Modifications to DID documents that are sent to an Orb servers are aggregated into batches prior to being announced on the decentralized network.
          By supporting batching, we enhance the scalability properties due to a reduction in messages and objects being stored.
          We inherit this property due to our usage of the [[[SIDETREE]]] protocol for encoding the DID document updates.
        </p>
      </section>

      <section class="normative">
        <h3>DID Updates Batches Form a Graph</h3>

        <p>
          When writing a batch of DID document updates, an Orb server also includes immutable references to the prior batches.
          These references form a graph (in the form of a Merkle Tree) such that the ancestor operations can be processed prior to a newly observed batch.
          This property is needed in the Orb data structures since we do not have a common blockchain to provide this history.
        </p>

        <p>
          When a DID controller supplies their DID, they also include a reference to a batch in their DID string. This reference allows an Orb server to discover
          the graph where a DID was created (or more generally where a <a href="https://identity.foundation/sidetree/spec/#core-index-file">core Sidetree</a> update occurred).
          This reference also enables the DID controller to specify a minimum version of the DID document that must be discovered in order to resolve.
        </p>
      </section>

      <section class="normative">
        <h3>CAS-based Verifiable Data Registry</h3>

        <p>
          The Orb VDR leverages <a href="https://en.wikipedia.org/wiki/Content-addressable_storage">Content-Addressable Storage</a> (CAS) to hold the DID document batch files.
          The processed batch files result in hosting resolvable DID documents.
          By supporting a CAS, we enhance the ability to replicate immutable content across the decentralized network.
          We inherit this property due to our usage of the [[[SIDETREE]]] protocol for encoding the DID document updates and batches.
        </p>

        <p>
          We also leverage the CAS to hold the graph of batches. The immutable references to prior batches are in the form of <a href="https://docs.ipfs.io/concepts/content-addressing/">content identifiers</a> (CIDs).
        </p>
      </section>

      <section class="normative">
        <h3>Witnesses Resolve Late Publishing</h3>

        <p>
          The Orb method relies on decentralized federation, gossip and CAS replication mechanisms to propagate
          the VDR among servers. The self certifying nature of Orb DIDs enables confidence in the DID validity without the need
          for network consensus. As the DID controller is fully responsible the changes to the DIDs, they can create a new branch
          in their changes even after time has passed.
          This situation is called <a href="https://identity.foundation/sidetree/spec/#late-publishing">late publishing</a>.
          The resolver systems require a mechanism to decide which branch should be used to represent the current DID state.
          It is also beneficial to create rules that enable a consistent viewpoint of the active branch among interconnected Orb servers.         
          Resolver systems use rules to determine the <i>first published fork</i> and use observations from Witness systems to assist in that decision.
        </p>

        <p>
          In the absence of Witnesses, we start with a simple rule: the first fork of a DID observed by an Orb server is the first published fork
          for that DID <i>from that server's point of view</i>. As Orb servers become increasingly interconnected, batches are gossiped between
          the Orb servers. Each server that forwards a batch includes a signed timestamp of when they observed the batch. The Orb Server MAY
          designate some of the other Orb servers as <i>trusted</i>. These trusted servers are then used to determine relative timing between batches.
          In the case that a majority viewpoint of itself and the other <i>trusted</i> Orb servers exists, that majority viewpoint will be used to
          determine the relative timing of the batches. From the relative timing of the batches, we also resolve the relative timing of the fork in the DID.
          An Orb server does not wait for consensus - its viewpoint may evenutally converge to a majority view, over time, in these situations.
        </p>
       
        <p>
          Rules exist to resolve the active branch so that Orb servers can consistently resolve the DID controller's intended and current DID document. 
          To mitigate against initial divergences, we also introduce the Witness role to observe a transaction prior to propagation.
          The Orb transaction writer <i>preannounces</i> the existence of an Orb transaction by submitting it to a Witness.
          A Witness creates a proof that they observed an Orb transaction at a certain time.
          Witnesses have the capability to provide timestamping and also host a Witness Ledger to provide relative ordering between merged sets of Orb Transactions.
        </p>

        <p>
          Although each Orb Server decides who to designate as trusted, it is also important that an Orb Server's behavior can be monitored.
          We use a Witness ledger as the mechanism for monitoring behavior - if inconsistencies are detected, other systems can adjust their viewpoint
          for trustworthiness.
          A Witness ledger is responsible for recording individual Orb transactions, providing signed transaction timestamps
          that can be embedded within a propagated Orb transaction, providing ledger consistency proofs, and providing an API that exposes their ledger.
          A Witness ledger is not responsible for maintaining the Orb transaction graph structure nor is it responsible for maintaining a complete history of Orb transactions.
          An Orb server is monitorable by exposing a Witness ledger API.
        </p>

        <p>
          We structure witnesses ledgers in a similar manner to certificate transparency [[RFC6962]], as append-only Merkle Trees with proof capabilities.
          A Witness ledger promises to include a submitted Orb transaction within a time period known as the Maximum Merge Delay (MMD).
          Once the ledger merges a set of Orb transactions into the Merkle Tree, a Signed Tree Head (STH) is produced.
          The STH (and associated Merkle Proofs) is used to validate consistency between older and newer ledger revisions.
        </p>

        <p class="issue" title="human time and ledger time">
          TODO: discussion about:
            <br>(1) Avoiding stale operations in the first place (try to meet the user's original intention) by using "human" time that is validated by writers and witnesses prior to propagation.
            <br>(2) Relative ordering is provided by ledger based on Tree Head positioning ("ledger" time). A Witness that is behaving will have matching "human" time and "ledger" time ordering.
            <br>(3) Servers periodically monitor the witness ledgers to ensure that signed transaction timestamps are included, that "ledger" time ordering matches "human" time ordering, and that the log is acting as append-only.
            <br>(4) Link relative timing discussion into section about Witness Associatation to a Suffix.
        </p>

        <p>
          When an Orb server creates a transaction, the server MAY request other Orb servers (as Witnesses) to include the transaction into their Witness ledger.
          The Orb server <i>preannounces</i> a transaction to Witnesses after preparing and writing the Sidetree CAS objects.
          The transaction announcement is then sent to Witnesses for validation and inclusion by the Witnesses.
          Each witnesses validates the Orb transaction structure and that it was issued within an acceptable delta of their current time.
          Witnesses MAY also validate that the Orb transaction originates from a known server that is acceptable to their policy.         
          Upon successful validation, each witness returns a signed transaction timestamp and a promise to include the Orb transaction into their Ledger.
          The Orb transaction (combined with the signed transaction timestamps) is then written into the CAS and propagated.
          When an Orb Server receives a propagated transaction, they MUST invalidate each Sidetree operation that has a JSON Web Token (JWT) [[RFC7519]] 
          "issued at" (iat) claim that is not within an acceptable delta of the Orb transaction's timestamp.
          When these proofs originate from <i>trusted</i> servers, their timing information is immediately applied after recieving an Orb transaction propagation.
          An Orb server that receives witnessed transactions from trusted servers likely holds the majority timing view immediately in these situations.
        </p>
      </section>

      <section class="normative">
        <h3>Witnesses Propagate for a Suffix</h3>
        <p>
          As Orb relies on gossip replication, it is possible for a resolver system to miss transactions originating from other servers that they do not follow.
          To mitigate this issue for a particular DID, we allow the DID controller to specify a witness policy.
          This policy contains a set of witnesses that MUST be used when an Orb transaction includes changes to the associated DID.
          The Writer server ensures that, according to the DID's policy, a sufficient number of these server(s) are also acceptable as Witnesses to the Writer server.
          If the DID's policy is unacceptable to the Writer server, the operation MUST be rejected and not included into the Orb transaction. The
          DID policy ensures that the Resolver Servers can determine if they have the latest propagations and that the DID controller can use any
          Writer server that has mutually acceptable policies.
        </p>

        <p class="issue" title="ledger time">
          When Witnesses are associated to a DID Suffix, Orb servers also have an additional trust signal for resolving late publishing scenarios.
        </p>

        <p>
          The ability to set (or change) the policy is an operation that is included into a propagated <a href="https://identity.foundation/sidetree/spec/#core-index-file">Sidetree core index</a>.
        </p>

      </section>

      <section class="normative">
        <h3>Web Discovery APIs are Supported</h3>

        <p>
          The Orb DID method enables CAS discovery and usage via Web APIs. The WebFinger protocol [[RFC7033]] allows systems to query for both
          [[ACTIVITYPUB]] endpoints and also for CAS endpoints for a given resource. By enabling a fully Web-enabled model, we do not introduce
          a requirement on <a href="https://en.wikipedia.org/wiki/Distributed_hash_table">Distributed Hash Table</a> (DHT) usage into the method.
        </p>
      </section>

      <section class="normative">
        <h3>Distributed Hash Tables are Supported</h3>

        <p>
          Although Orb DIDs can be created that do not have a dependency on DHTs, we also enable optional support for registering CAS resources on a DHT.
          Orb servers MAY choose to expose their CAS-based VDRs on a <a href="https://en.wikipedia.org/wiki/Distributed_hash_table">Distributed Hash Table</a> (DHT) network such as IPFS. 
          When using a DHT, we gain the advantage of not needing to specify any Web domain to be queried for discovery.
        </p>
      </section>

      <section class="normative">
        <h3>Graphs Enable Propagation Discovery</h3>

        <p>
          The Orb transaction graph that is stored into the content-addressable storage (CAS) also enables discovery of propagation properties.
          Each node in the transaction graph includes known CAS discovery information and witness endpoints.
          The CAS discovery information enable Orb servers to include additional endpoints when responding to WebFinger [[RFC7033]] queries.
          The witness endpoints enable Orb servers to follow additional systems for propagation.
        </p>

      </section>

    </section>

    <section class="normative">
        <h2 id="format">The did:orb Format</h2>

        <p>
            The format for the <tt>did:orb</tt> method conforms to the [[[DID-CORE]]] specification.
            The DID scheme consists of the did:orb prefix, the mechanism for discovering content-addressable objects,
            a content identifier (CID) for the minimum node in the DID operation batch graph, and the unique suffix of the DID.
        </p>
        
        <p>  
            The method uses the following ABNF [[RFC5234]] format:
        </p>

        <pre>
          did-orb-format       = "did:orb:" cas-discovery-scheme ":" 
                                 min-graph-cid ":" unique-suffix
          cas-discovery-scheme = dht-scheme / web-scheme
          dht-scheme           = ( "ipfs" )
          web-scheme           = "web:" reg-name
          reg-name             = 1*idchar                ; more constrained than [RFC3986]
          min-graph-cid        = 1*idchar
          unique-suffix        = 1*idchar
        </pre>

        <p>
          See [[?RFC3986]] for the original definition of reg-name and [[DID-CORE]] for the definition of idchar.
        </p>

        <pre class="example" title="An Orb DID that uses the Web scheme for content discovery">
          did:orb:web:example.com:bafkreiatkubvbkdidscmqynkyls3iqawdqvthi7e6mbky2amuw3inxsi3y:EiDyOQbbZAa3aiRzeCkV7LOx3SERjjH93EXoIM3UoN4oWg
        </pre>

        <pre class="example" title="An Orb DID that uses the IPFS scheme for content discovery">
          did:orb:ipfs:bafkreiatkubvbkdidscmqynkyls3iqawdqvthi7e6mbky2amuw3inxsi3y:EiDyOQbbZAa3aiRzeCkV7LOx3SERjjH93EXoIM3UoN4oWg
        </pre>

        <p class="issue" title="default DHT">
          TODO: discussion about not including a CAS discovery scheme and the possibility of a DHT profile for Orb.
        </p>
      </section>

    <section class="normative">
        <h2>Client-to-Server Operations</h2>

        <p>
        </p>

        <section class="normative">
            <h3>Create</h3>

            <p>
            </p>
        </section>

        <section class="normative">
            <h3>Read</h3>

            <p>
            </p>
        </section>

        <section class="normative">
            <h3>Update</h3>

            <p>
            </p>
        </section>

        <section class="normative">
            <h3>Deactivate</h3>

            <p>
            </p>
        </section>
    </section>

    <section class="normative">
        <h2>Transaction Graph</h2>

        <p>
        </p>

        <section class="normative">
            <h3>Content Addressable Storage</h3>

            <p>
            </p>
        </section>

        <section class="normative">
            <h3>Transaction</h3>

            <p>
            </p>
        </section>

        <section class="normative">
            <h3>Sidetree Protocol</h3>

            <p>
            </p>
        </section>

        <section class="normative">
          <h3>Checkpoint Operation</h3>

          <p>
          </p>
      </section>
    </section>

    <section class="normative">
      <h2>Witness Ledger</h2>

      <p>
      </p>
    </section>

    <section class="normative">
        <h2>Server-to-Server APIs</h2>

        <p>
        </p>

        <section class="normative">
          <h3>ActivityPub</h3>

          <p>
          </p>
        </section>

        <section class="normative">
          <h3>WebFinger</h3>

          <p>
          </p>
        </section>

        <section class="normative">
          <h3>Content Addressable Storage</h3>

          <p>
          </p>
        </section>

        <section class="normative">
          <h3>Distributed Hash Table</h3>

          <p class="issue" title="An Orb DHT profile may be considered in the future">
            We currently enable usage of the IPFS DHT.
            In the future, we may want to additionally consider an Orb-specific profile to limit usage to VDRs.
          </p>
        </section>

      </section>

    <section class="informative">
        <h2>Security Considerations</h2>

        <p>
        </p>
    </section>
        
    <section class="informative">
      <h2>Privacy Considerations</h2>

      <section class="informative">
        <h3>Keep Personally-Identifiable Information (PII) Private</h3>

        <p>
        </p>
      </section>

      <section class="informative">
        <h3>DID Correlation Risks and Pseudonymous DIDs</h3>

        <p>
        </p>
      </section>
    </section>

    <section id='conformance'>
      <!-- This section is filled automatically by ReSpec. -->
    </section>
  </body>
</html>